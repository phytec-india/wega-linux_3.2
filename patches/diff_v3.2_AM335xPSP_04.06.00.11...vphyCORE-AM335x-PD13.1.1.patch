diff --git a/Documentation/input/edt-ft5x06.txt b/Documentation/input/edt-ft5x06.txt
new file mode 100644
index 0000000..2032f0b
--- /dev/null
+++ b/Documentation/input/edt-ft5x06.txt
@@ -0,0 +1,54 @@
+EDT ft5x06 based Polytouch devices
+----------------------------------
+
+The edt-ft5x06 driver is useful for the EDT "Polytouch" family of capacitive
+touch screens. Note that it is *not* suitable for other devices based on the
+focaltec ft5x06 devices, since they contain vendor-specific firmware. In
+particular this driver is not suitable for the Nook tablet.
+
+It has been tested with the following devices:
+  * EP0350M06
+  * EP0430M06
+  * EP0570M06
+  * EP0700M06
+
+The driver allows configuration of the touch screen via a set of sysfs files:
+
+/sys/class/input/eventX/device/device/threshold:
+    allows setting the "click"-threshold in the range from 20 to 80.
+
+/sys/class/input/eventX/device/device/gain:
+    allows setting the sensitivity in the range from 0 to 31. Note that
+    lower values indicate higher sensitivity.
+
+/sys/class/input/eventX/device/device/offset:
+    allows setting the edge compensation in the range from 0 to 31.
+
+/sys/class/input/eventX/device/device/report_rate:
+    allows setting the report rate in the range from 3 to 14.
+
+
+For debugging purposes the driver provides a few files in the debug
+filesystem (if available in the kernel). In /sys/kernel/debug/edt_ft5x06
+you'll find the following files:
+
+num_x, num_y:
+    (readonly) contains the number of sensor fields in X- and
+    Y-direction.
+
+mode:
+    allows switching the sensor between "factory mode" and "operation
+    mode" by writing "1" or "0" to it. In factory mode (1) it is
+    possible to get the raw data from the sensor. Note that in factory
+    mode regular events don't get delivered and the options described
+    above are unavailable.
+
+raw_data:
+    contains num_x * num_y big endian 16 bit values describing the raw
+    values for each sensor field. Note that each read() call on this
+    files triggers a new readout. It is recommended to provide a buffer
+    big enough to contain num_x * num_y * 2 bytes.
+
+Note that reading raw_data gives a I/O error when the device is not in factory
+mode. The same happens when reading/writing to the parameter files when the
+device is not in regular operation mode.
diff --git a/arch/arm/configs/pcaaxs1_defconfig b/arch/arm/configs/pcaaxs1_defconfig
new file mode 100644
index 0000000..5ce873c
--- /dev/null
+++ b/arch/arm/configs/pcaaxs1_defconfig
@@ -0,0 +1,245 @@
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_PERF_EVENTS is not set
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_OMAP=y
+CONFIG_OMAP_MUX_DEBUG=y
+# CONFIG_OMAP_MCBSP is not set
+CONFIG_OMAP_MBOX_FWK=y
+# CONFIG_OMAP_32K_TIMER is not set
+# CONFIG_ARCH_OMAP2 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP3430 is not set
+# CONFIG_SOC_OMAPTI81XX is not set
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_DEVKIT8000 is not set
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OMAP3530_LV_SOM is not set
+# CONFIG_MACH_OMAP3_TORPEDO is not set
+# CONFIG_MACH_ENCORE is not set
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3EVM is not set
+# CONFIG_MACH_OMAP3517EVM is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+# CONFIG_MACH_OMAP3_TOUCHBOOK is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_NOKIA_RM680 is not set
+# CONFIG_MACH_NOKIA_RX51 is not set
+# CONFIG_MACH_OMAP_ZOOM2 is not set
+# CONFIG_MACH_OMAP_ZOOM3 is not set
+# CONFIG_MACH_CM_T35 is not set
+# CONFIG_MACH_CM_T3517 is not set
+# CONFIG_MACH_IGEP0020 is not set
+# CONFIG_MACH_IGEP0030 is not set
+# CONFIG_MACH_SBC3530 is not set
+# CONFIG_MACH_OMAP_3630SDP is not set
+# CONFIG_MACH_AM335XEVM is not set
+# CONFIG_MACH_AM335XIAEVM is not set
+# CONFIG_MACH_PCM051 is not set
+CONFIG_OMAP3_EDMA=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/mmcblk0p2 rootwait console=ttyO0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_IDLE=y
+CONFIG_FPE_NWFPE=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_D_CAN=y
+CONFIG_CAN_D_CAN_PLATFORM=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_RFKILL=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_OMAP2=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_MISC_DEVICES=y
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_TI_DAVINCI_EMAC=y
+CONFIG_TI_CPSW=y
+CONFIG_TI_CPSW_DUAL_EMAC=y
+CONFIG_SMSC_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_WL12XX_MENU=y
+CONFIG_WL12XX=m
+CONFIG_WL12XX_SDIO=m
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_MATRIX=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_TI_TSCADC=y
+CONFIG_TOUCHSCREEN_STMPE=y
+CONFIG_INPUT_MISC=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GENERIC_PWM=y
+CONFIG_DAVINCI_EHRPWM=y
+CONFIG_ECAP_PWM=y
+CONFIG_SENSORS_LM75=y
+CONFIG_WATCHDOG=y
+CONFIG_OMAP_WATCHDOG=y
+CONFIG_MFD_TPS65910=y
+CONFIG_MFD_STMPE=y
+CONFIG_REGULATOR_DUMMY=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+CONFIG_FB_DA8XX=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_TLC59108=y
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_TI81XX_GLUE=y
+CONFIG_USB_TI_CPPI41_DMA_HW=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_MMC=y
+CONFIG_MMC_OMAP_HS=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_PCA9532=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PCF8563=y
+CONFIG_RTC_DRV_TPS65910=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_CRAMFS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_JTAG_ENABLE=y
+CONFIG_SECURITY=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_CCITT=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
diff --git a/arch/arm/configs/pcm051_defconfig b/arch/arm/configs/pcm051_defconfig
new file mode 100644
index 0000000..ea02b0d
--- /dev/null
+++ b/arch/arm/configs/pcm051_defconfig
@@ -0,0 +1,246 @@
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_PERF_EVENTS is not set
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_OMAP=y
+CONFIG_OMAP_MUX_DEBUG=y
+# CONFIG_OMAP_MCBSP is not set
+CONFIG_OMAP_MBOX_FWK=y
+# CONFIG_OMAP_32K_TIMER is not set
+# CONFIG_ARCH_OMAP2 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP3430 is not set
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_DEVKIT8000 is not set
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OMAP3530_LV_SOM is not set
+# CONFIG_MACH_OMAP3_TORPEDO is not set
+# CONFIG_MACH_ENCORE is not set
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3EVM is not set
+# CONFIG_MACH_OMAP3517EVM is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+# CONFIG_MACH_OMAP3_TOUCHBOOK is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_NOKIA_RM680 is not set
+# CONFIG_MACH_NOKIA_RX51 is not set
+# CONFIG_MACH_OMAP_ZOOM2 is not set
+# CONFIG_MACH_OMAP_ZOOM3 is not set
+# CONFIG_MACH_CM_T35 is not set
+# CONFIG_MACH_CM_T3517 is not set
+# CONFIG_MACH_IGEP0020 is not set
+# CONFIG_MACH_IGEP0030 is not set
+# CONFIG_MACH_SBC3530 is not set
+# CONFIG_MACH_OMAP_3630SDP is not set
+# CONFIG_MACH_AM335XEVM is not set
+# CONFIG_MACH_AM335XIAEVM is not set
+CONFIG_OMAP3_EDMA=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/mmcblk0p2 rootwait console=ttyO0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_FPE_NWFPE=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_D_CAN=y
+CONFIG_CAN_D_CAN_PLATFORM=y
+CONFIG_RFKILL=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_OOPS=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_OMAP2=y
+CONFIG_MTD_ONENAND=y
+CONFIG_MTD_ONENAND_VERIFY_WRITE=y
+CONFIG_MTD_ONENAND_OMAP2=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_MISC_DEVICES=y
+CONFIG_SENSORS_TSL2550=y
+CONFIG_EEPROM_AT24=y
+CONFIG_SENSORS_LIS3_I2C=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_NETDEVICES=y
+CONFIG_SMC91X=y
+CONFIG_SMSC911X=y
+CONFIG_TI_CPSW=y
+CONFIG_SMSC_PHY=y
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_MATRIX=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_INPUT_MISC=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_SPI=y
+CONFIG_SPI_OMAP24XX=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GENERIC_PWM=y
+CONFIG_DAVINCI_EHRPWM=y
+CONFIG_ECAP_PWM=y
+CONFIG_SENSORS_LM75=y
+CONFIG_WATCHDOG=y
+CONFIG_OMAP_WATCHDOG=y
+CONFIG_MFD_TPS65217=y
+CONFIG_MFD_TPS65910=y
+CONFIG_REGULATOR_DUMMY=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_TPS65217=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+CONFIG_FB_DA8XX=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_TLC59108=y
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_AM33XX_SOC=y
+CONFIG_SND_PCM051_SOC_BOARD=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_TI81XX_GLUE=y
+CONFIG_USB_TI_CPPI41_DMA_HW=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MUSB_HDRC=y
+CONFIG_USB_ETH=m
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_SDIO_UART=y
+CONFIG_MMC_OMAP_HS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_OMAP=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_UBIFS_FS=y
+CONFIG_CRAMFS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_JTAG_ENABLE=y
+CONFIG_SECURITY=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_CCITT=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+CONFIG_AVERAGE=y
diff --git a/arch/arm/configs/pfla03_defconfig b/arch/arm/configs/pfla03_defconfig
new file mode 100644
index 0000000..238cb43
--- /dev/null
+++ b/arch/arm/configs/pfla03_defconfig
@@ -0,0 +1,204 @@
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_PERF_EVENTS is not set
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_OMAP=y
+CONFIG_OMAP_MUX_DEBUG=y
+# CONFIG_OMAP_MCBSP is not set
+CONFIG_OMAP_MBOX_FWK=y
+# CONFIG_OMAP_32K_TIMER is not set
+# CONFIG_ARCH_OMAP2 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP3430 is not set
+# CONFIG_SOC_OMAPTI81XX is not set
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_DEVKIT8000 is not set
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OMAP3530_LV_SOM is not set
+# CONFIG_MACH_OMAP3_TORPEDO is not set
+# CONFIG_MACH_ENCORE is not set
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3EVM is not set
+# CONFIG_MACH_OMAP3517EVM is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+# CONFIG_MACH_OMAP3_TOUCHBOOK is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_NOKIA_RM680 is not set
+# CONFIG_MACH_NOKIA_RX51 is not set
+# CONFIG_MACH_OMAP_ZOOM2 is not set
+# CONFIG_MACH_OMAP_ZOOM3 is not set
+# CONFIG_MACH_CM_T35 is not set
+# CONFIG_MACH_CM_T3517 is not set
+# CONFIG_MACH_IGEP0020 is not set
+# CONFIG_MACH_IGEP0030 is not set
+# CONFIG_MACH_SBC3530 is not set
+# CONFIG_MACH_OMAP_3630SDP is not set
+# CONFIG_MACH_AM335XEVM is not set
+# CONFIG_MACH_AM335XIAEVM is not set
+# CONFIG_MACH_PCM051 is not set
+# CONFIG_MACH_PCAAXS1 is not set
+CONFIG_OMAP3_EDMA=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/mmcblk0p2 rootwait console=ttyO0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_IDLE=y
+CONFIG_FPE_NWFPE=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_EXTRA_FIRMWARE="am335x-pm-firmware.bin"
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_M25P80=y
+# CONFIG_M25PXX_USE_FAST_READ is not set
+CONFIG_MTD_NAND_ECC_SMC=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_OMAP2=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_MISC_DEVICES=y
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_MATRIX=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_INPUT_MISC=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_SPI=y
+CONFIG_SPI_OMAP24XX=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GENERIC_PWM=y
+CONFIG_DAVINCI_EHRPWM=y
+CONFIG_ECAP_PWM=y
+CONFIG_SENSORS_LM75=y
+CONFIG_WATCHDOG=y
+CONFIG_OMAP_WATCHDOG=y
+CONFIG_MFD_TPS65217=y
+CONFIG_MFD_TPS65910=y
+CONFIG_REGULATOR_DUMMY=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_TPS65217=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_FB=y
+CONFIG_FB_FOREIGN_ENDIAN=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+CONFIG_FB_DA8XX=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_TLC59108=y
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DYNAMIC_MINORS=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_TI81XX_GLUE=y
+CONFIG_USB_TI_CPPI41_DMA_HW=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_MMC=y
+CONFIG_MMC_OMAP_HS=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_PCA9532=y
+CONFIG_LEDS_PCA9532_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PCF8563=y
+CONFIG_STAGING=y
+CONFIG_IIO=y
+CONFIG_MAX1363=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_XATTR=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_CRAMFS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_JTAG_ENABLE=y
+CONFIG_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_CCITT=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+CONFIG_AVERAGE=y
diff --git a/arch/arm/mach-davinci/devices-da8xx.c b/arch/arm/mach-davinci/devices-da8xx.c
index b899238..9ca2235 100644
--- a/arch/arm/mach-davinci/devices-da8xx.c
+++ b/arch/arm/mach-davinci/devices-da8xx.c
@@ -641,9 +641,14 @@ static struct platform_device da8xx_lcdc_device = {
 	.resource	= da8xx_lcdc_resources,
 };
 
+static struct da8xx_lcdc_selection_platform_data da8xx_lcdc_selection;
+
 int __init da8xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata)
 {
-	da8xx_lcdc_device.dev.platform_data = pdata;
+	da8xx_lcdc_selection.entries_ptr = pdata;
+	da8xx_lcdc_selection.entries_cnt = 1;
+	da8xx_lcdc_device.dev.platform_data = &da8xx_lcdc_selection;
+
 	return platform_device_register(&da8xx_lcdc_device);
 }
 
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index e44e942..5865746 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -32,7 +32,7 @@ config ARCH_OMAP3
 	depends on ARCH_OMAP2PLUS
 	default y
 	select CPU_V7
-	select USB_ARCH_HAS_EHCI
+	select USB_ARCH_HAS_EHCI if USB_SUPPORT
 	select ARM_L1_CACHE_SHIFT_6 if !ARCH_OMAP4
 	select ARCH_HAS_OPP
 	select PM_OPP if PM
@@ -51,7 +51,7 @@ config ARCH_OMAP4
 	select ARM_ERRATA_720789
 	select ARCH_HAS_OPP
 	select PM_OPP if PM
-	select USB_ARCH_HAS_EHCI
+	select USB_ARCH_HAS_EHCI if USB_SUPPORT
 	select ARM_CPU_SUSPEND if PM
 
 comment "OMAP Core Type"
@@ -364,6 +364,21 @@ config MACH_PCM049
 	default y
 	select OMAP_PACKAGE_CBS
 
+config MACH_PCM051
+	bool "AM335X based phyCORE AM335X"
+	depends on SOC_OMAPAM33XX
+	default y
+
+config MACH_PCAAXS1
+	bool "AM335X based phyCARD AM335X"
+	depends on SOC_OMAPAM33XX
+	default y
+
+config MACH_PFLA03
+	bool "AM335X based phyFLEX AM335X"
+	depends on SOC_OMAPAM33XX
+	default y
+
 config OMAP3_EMU
 	bool "OMAP3 debugging peripherals"
 	depends on ARCH_OMAP3
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index f275e74..f3de850 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -47,7 +47,7 @@ obj-$(CONFIG_SOC_OMAP2420)		+= mux2420.o
 obj-$(CONFIG_SOC_OMAP2430)		+= mux2430.o
 obj-$(CONFIG_ARCH_OMAP3)		+= mux34xx.o
 obj-$(CONFIG_ARCH_OMAP4)		+= mux44xx.o
-obj-$(CONFIG_SOC_OMAPAM33XX)           += mux33xx.o
+obj-$(CONFIG_SOC_OMAPAM33XX)           += mux33xx.o am33xx_generic.o
 
 # SMS/SDRC
 obj-$(CONFIG_ARCH_OMAP2)		+= sdrc2xxx.o
@@ -256,6 +256,10 @@ obj-$(CONFIG_MACH_TI8148EVM)		+= board-ti8168evm.o
 obj-$(CONFIG_MACH_AM335XEVM)		+= board-am335xevm.o
 obj-$(CONFIG_MACH_AM335XIAEVM)		+= board-am335xevm.o
 
+obj-$(CONFIG_MACH_PCM051)		+= board-pcm051.o
+obj-$(CONFIG_MACH_PCAAXS1)		+= board-pcaaxs1.o
+obj-$(CONFIG_MACH_PFLA03)		+= board-pfla03.o
+
 # Platform specific device init code
 
 omap-flash-$(CONFIG_MTD_NAND_OMAP2)	:= board-flash.o
diff --git a/arch/arm/mach-omap2/am33xx_generic.c b/arch/arm/mach-omap2/am33xx_generic.c
new file mode 100644
index 0000000..e165408
--- /dev/null
+++ b/arch/arm/mach-omap2/am33xx_generic.c
@@ -0,0 +1,126 @@
+/*
+ * Some AM335X generic board code.
+ *
+ * Copyright (C) 2013 Teresa Gámez Zerban <t.gamez@phytec.de>
+ *
+ * Based on AM335x EVM:
+ * Copyright (C) 2011 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/rtc/rtc-omap.h>
+#include <mach/hardware.h>
+#include <plat/omap_hwmod.h>
+#include <plat/omap_device.h>
+#include <asm/io.h>
+
+void __iomem *am33xx_emif_base;
+
+void __iomem * __init am33xx_get_mem_ctlr(void)
+{
+	am33xx_emif_base = ioremap(AM33XX_EMIF0_BASE, SZ_32K);
+
+	if (!am33xx_emif_base)
+		pr_warning("%s: Unable to map DDR3 controller", __func__);
+
+	return am33xx_emif_base;
+}
+
+void __iomem *am33xx_get_ram_base(void)
+{
+	return am33xx_emif_base;
+}
+
+void __iomem *am33xx_gpio0_base;
+
+void __iomem *am33xx_get_gpio0_base(void)
+{
+	am33xx_gpio0_base = ioremap(AM33XX_GPIO0_BASE, SZ_4K);
+
+	return am33xx_gpio0_base;
+}
+
+/* unlock values for rtc */
+#define RTC_UNLOCK_VAL1			0x83e70b13
+#define RTC_UNLOCK_VAL2			0x95a4f1e0
+
+/* offset addr for unlock and clock control reg */
+#define RTC_KICK0R_OFFSET		0x6c
+#define RTC_KICK1R_OFFSET		0x70
+#define RTC_OSC_REG_OFFSET		0x54
+
+/* clock control reg bits */
+#define RTC_32K_CLK_SEL_EX		(0x1 << 3)
+#define RTC_32K_CLK_EN			(0x1 << 6)
+
+static struct omap_rtc_pdata am335x_rtc_info = {
+	.pm_off		= false,
+	.wakeup_capable	= 0,
+};
+
+void am335x_internal_rtc_init(void)
+{
+	void __iomem *base;
+	struct clk *clk;
+	struct omap_hwmod *oh;
+	struct platform_device *pdev;
+	char *dev_name = "am33xx-rtc";
+
+	clk = clk_get(NULL, "rtc_fck");
+	if (IS_ERR(clk)) {
+		pr_err("rtc : Failed to get RTC clock\n");
+		return;
+	}
+
+	if (clk_enable(clk)) {
+		pr_err("rtc: Clock Enable Failed\n");
+		return;
+	}
+
+	base = ioremap(AM33XX_RTC_BASE, SZ_4K);
+
+	if (WARN_ON(!base))
+		return;
+
+	/* Unlock the rtc's registers */
+	writel(RTC_UNLOCK_VAL1, base + RTC_KICK0R_OFFSET);
+	writel(RTC_UNLOCK_VAL2, base + RTC_KICK1R_OFFSET);
+
+	/*
+	 * Enable the 32K OSc
+	 * TODO: Need a better way to handle this
+	 * we need to do it before the rtc probe happens
+	 */
+	writel((RTC_32K_CLK_SEL_EX | RTC_32K_CLK_EN),\
+			base + RTC_OSC_REG_OFFSET);
+
+	iounmap(base);
+
+	clk_disable(clk);
+	clk_put(clk);
+
+	if (omap_rev() == AM335X_REV_ES2_0)
+		am335x_rtc_info.wakeup_capable = 1;
+
+	oh = omap_hwmod_lookup("rtc");
+	if (!oh) {
+		pr_err("could not look up %s\n", "rtc");
+		return;
+	}
+
+	pdev = omap_device_build(dev_name, -1, oh, &am335x_rtc_info,
+			sizeof(struct omap_rtc_pdata), NULL, 0, 0);
+	WARN(IS_ERR(pdev), "Can't build omap_device for %s:%s.\n",
+			dev_name, oh->name);
+}
diff --git a/arch/arm/mach-omap2/am33xx_generic.h b/arch/arm/mach-omap2/am33xx_generic.h
new file mode 100644
index 0000000..5bc2ef0
--- /dev/null
+++ b/arch/arm/mach-omap2/am33xx_generic.h
@@ -0,0 +1,13 @@
+#ifndef __ARCH_ARM_MACH_OMAP2_AM335X_GENERIC_H
+#define __ARCH_ARM_MACH_OMAP2_AM335X_GENERIC_H
+
+extern void __iomem *am33xx_emif_base;
+extern void __iomem * __init am33xx_get_mem_ctlr(void);
+extern void __iomem *am33xx_get_ram_base(void);
+
+extern void __iomem *am33xx_gpio0_base;
+extern void __iomem *am33xx_get_gpio0_base(void);
+
+void am335x_internal_rtc_init(void);
+
+#endif
diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index 8f79e26..f8f3086 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -146,6 +146,8 @@ struct da8xx_lcdc_platform_data  NHD_480272MF_ATXI_pdata = {
 	.type                   = "NHD-4.3-ATXI#-T-1",
 };
 
+static struct da8xx_lcdc_selection_platform_data da8xx_lcdc_selection;
+
 #include "common.h"
 
 #include <linux/lis3lv02d.h>
@@ -1049,7 +1051,6 @@ out:
 
 static void lcdc_init(int evm_id, int profile)
 {
-	struct da8xx_lcdc_platform_data *lcdc_pdata;
 	setup_pin_mux(lcdc_pin_mux);
 
 	if (conf_disp_pll(300000000)) {
@@ -1061,9 +1062,10 @@ static void lcdc_init(int evm_id, int profile)
 	case GEN_PURP_EVM:
 	case GEN_PURP_DDR3_EVM:
 		lcdc_pdata = &TFC_S9700RTWV35TR_01B_pdata;
+		da8xx_lcdc_selection.entries_ptr = &TFC_S9700RTWV35TR_01B_pdata;
 		break;
 	case EVM_SK:
-		lcdc_pdata = &NHD_480272MF_ATXI_pdata;
+		da8xx_lcdc_selection.entries_ptr = &NHD_480272MF_ATXI_pdata;
 		break;
 	default:
 		pr_err("LCDC not supported on this evm (%d)\n",evm_id);
@@ -1073,6 +1075,9 @@ static void lcdc_init(int evm_id, int profile)
 	lcdc_pdata->get_context_loss_count = omap_pm_get_dev_context_loss_count;
 
 	if (am33xx_register_lcdc(lcdc_pdata))
+		da8xx_lcdc_selection.entries_cnt = 1;
+
+	if (am33xx_register_lcdc(&da8xx_lcdc_selection))
 		pr_info("Failed to register LCDC device\n");
 
 	return;
diff --git a/arch/arm/mach-omap2/board-pcaaxs1.c b/arch/arm/mach-omap2/board-pcaaxs1.c
new file mode 100644
index 0000000..fb2c333
--- /dev/null
+++ b/arch/arm/mach-omap2/board-pcaaxs1.c
@@ -0,0 +1,725 @@
+/*
+ * Board support file for Phytec phyCARD-AM335x Board.
+ *
+ * Copyright (C) 2013 Phytec Embedded Pvt. Ltd.
+ *
+ * Author: Trilokesh Rangam <lokesh.r@phytec.in>
+ *
+ * Based on mach-omap2/board-am335xevm.c
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/i2c/at24.h>
+#include <linux/phy.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/ethtool.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/mfd/tps65217.h>
+#include <linux/input/edt-ft5x06.h>
+#include <linux/input/ti_tsc.h>
+#include <linux/platform_data/ti_adc.h>
+#include <linux/mfd/ti_tscadc.h>
+#include <linux/pwm_backlight.h>
+#include <linux/mfd/stmpe.h>
+#include <linux/pwm/pwm.h>
+#include <linux/reboot.h>
+#include <linux/opp.h>
+#include <linux/micrel_phy.h>
+#include <linux/leds-pca9532.h>
+
+/* LCD controller is similar to DA850 */
+#include <video/da8xx-fb.h>
+
+#include <mach/hardware.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/hardware/asp.h>
+
+#include <plat/omap_device.h>
+#include <plat/irqs.h>
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/mmc.h>
+#include <plat/emif.h>
+#include <plat/nand.h>
+#include <plat/lcdc.h>
+#include <plat/usb.h>
+
+#include "board-flash.h"
+#include "cpuidle33xx.h"
+#include "mux.h"
+#include "hsmmc.h"
+#include "devices.h"
+
+/* Convert GPIO signal to GPIO pin number */
+#define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
+#include "common.h"
+
+#define GPIO_RTC_PMIC_IRQ  GPIO_TO_PIN(1, 19)
+#define AM335X_PHYCARD_STMPE811_GPIO_IRQ  GPIO_TO_PIN(0, 7)
+#define AM335X_PHYCARD_EDT_FT5X06_GPIO_IRQ GPIO_TO_PIN(0, 12)
+#define EEPROM_I2C_ADDR         0x54
+
+#include "am33xx_generic.h"
+
+/* TSc controller */
+#include <linux/lis3lv02d.h>
+
+static const struct display_panel disp_panel = {
+	VGA,
+	32,
+	32,
+	COLOR_ACTIVE,
+};
+
+/* LCD backlight platform Data */
+#define AM335X_BACKLIGHT_MAX_BRIGHTNESS        100
+#define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    100
+#define AM335X_PWM_PERIOD_NANO_SECONDS         100000
+
+static struct lcd_ctrl_config lcd_cfg = {
+	&disp_panel,
+	.ac_bias                = 40,
+	.ac_bias_intrpt         = 0,
+	.dma_burst_sz           = 16,
+	.bpp                    = 32,
+	.fdd                    = 0x80,
+	.tft_alt_mode           = 0,
+	.stn_565_mode           = 0,
+	.mono_8bit_mode         = 0,
+	.invert_line_clock      = 1,
+	.invert_frm_clock       = 1,
+	.sync_edge              = 0,
+	.sync_ctrl              = 1,
+	.raster_order           = 0,
+};
+
+static void pcaaxs1_display_power(int power)
+{
+	/* Enable/Disable LVDS transceiver */
+	gpio_direction_output(GPIO_TO_PIN(1, 17), power);
+}
+
+static struct da8xx_lcdc_platform_data lcdc_pdata[] = {
+	{
+		.manu_name		= "Emerging",
+		.controller_data	= &lcd_cfg,
+		.type			= "ETM0700G0DH6",
+		.panel_power_ctrl	= pcaaxs1_display_power,
+	}, {
+		.manu_name              = "PrimeView",
+		.controller_data        = &lcd_cfg,
+		.type                   = "PV_PM070WL4",
+		.panel_power_ctrl	= pcaaxs1_display_power,
+	}, {
+		.manu_name              = "PrimeView",
+		.controller_data        = &lcd_cfg,
+		.type                   = "PV_PD050VL1",
+		.panel_power_ctrl	= pcaaxs1_display_power,
+	}, {
+		.manu_name              = "PrimeView",
+		.controller_data        = &lcd_cfg,
+		.type                   = "PV_PD104SLF",
+		.panel_power_ctrl	= pcaaxs1_display_power,
+	},
+};
+
+static struct da8xx_lcdc_selection_platform_data lcdc_selection_pdata = {
+	.entries_ptr = lcdc_pdata,
+	.entries_cnt = ARRAY_SIZE(lcdc_pdata)
+};
+
+static struct omap2_hsmmc_info am335x_mmc[] __initdata = {
+	{
+		.mmc            = 1,
+		.caps           = MMC_CAP_4_BIT_DATA,
+		.gpio_cd        = GPIO_TO_PIN(0, 31),
+		.gpio_wp        = -EINVAL,
+		.ocr_mask       = MMC_VDD_32_33 | MMC_VDD_33_34, /* 3V3 */
+	},
+	{
+		.mmc            = 0,    /* will be set at runtime */
+	},
+	{
+		.mmc            = 0,    /* will be set at runtime */
+	},
+	{}      /* Terminator */
+};
+
+/* module pin mux structure */
+struct pinmux_config {
+	const char *string_name; /* signal name format */
+	int val; /* Options for the mux register value */
+};
+
+/*
+* @pin_mux - single module pin-mux structure which defines pin-mux
+*			details for all its pins.
+*/
+static void setup_pin_mux(struct pinmux_config *pin_mux)
+{
+	int i;
+
+	for (i = 0; pin_mux->string_name != NULL; pin_mux++)
+		omap_mux_init_signal(pin_mux->string_name, pin_mux->val);
+
+}
+
+/* Module pin mux for mmc0 */
+static struct pinmux_config mmc0_pin_mux[] = {
+	{"mmc0_dat3.mmc0_dat3",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat2.mmc0_dat2",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat1.mmc0_dat1",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat0.mmc0_dat0",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_clk.mmc0_clk",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_cmd.mmc0_cmd",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_wpn.gpio0_31",	OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* Module pin mux for i2c0 */
+static struct pinmux_config i2c0_pin_mux[] = {
+	{"i2c0_sda.i2c0_sda", OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
+				AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT},
+	{"i2c0_scl.i2c0_scl", OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
+				AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+/* Module pin mux for i2c1 */
+static struct pinmux_config i2c1_pin_mux[] = {
+	{"uart1_rxd.i2c1_sda", OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
+					AM33XX_PIN_INPUT_PULLUP},
+	{"uart1_txd.i2c1_scl", OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
+					AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+static struct pinmux_config rtc_pin_mux[] = {
+	{"gpmc_a3.gpio1_19", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* Pin mux for nand flash module */
+static struct pinmux_config nand_pin_mux[] = {
+	{"gpmc_ad0.gpmc_ad0",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad1.gpmc_ad1",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad2.gpmc_ad2",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad3.gpmc_ad3",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad4.gpmc_ad4",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad5.gpmc_ad5",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad6.gpmc_ad6",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad7.gpmc_ad7",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_wait0.gpmc_wait0", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_wpn.gpmc_wpn",     OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_csn0.gpmc_csn0",   OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_advn_ale.gpmc_advn_ale",  OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_oen_ren.gpmc_oen_ren",    OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_wen.gpmc_wen",     OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_ben0_cle.gpmc_ben0_cle",  OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{NULL, 0},
+};
+
+static struct pinmux_config lcdc_pin_mux[] = {
+	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data1.lcd_data1",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data2.lcd_data2",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data3.lcd_data3",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data4.lcd_data4",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data5.lcd_data5",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data6.lcd_data6",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data7.lcd_data7",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data8.lcd_data8",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data9.lcd_data9",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data10.lcd_data10",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data11.lcd_data11",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data12.lcd_data12",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data13.lcd_data13",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data14.lcd_data14",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data15.lcd_data15",       OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"gpmc_ad8.lcd_data16",		OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad9.lcd_data17",		OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad10.lcd_data18",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad11.lcd_data19",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad12.lcd_data20",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad13.lcd_data21",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad14.lcd_data22",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad15.lcd_data23",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"lcd_vsync.lcd_vsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_hsync.lcd_hsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_pclk.lcd_pclk",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a1.gpio1_17",		OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+static struct pinmux_config ts_irq_mux[] = {
+	{"ecap0_in_pwm0_out.gpio0_7",
+		OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
+	{"uart1_ctsn.gpio0_12", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
+	{NULL, 0},
+};
+
+static struct pinmux_config tsc_pin_mux[] = {
+	{"ain0.ain0",		OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain1.ain1",		OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain2.ain2",		OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain3.ain3",		OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"vrefp.vrefp",		OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"vrefn.vrefn",		OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{NULL, 0},
+};
+
+/* pinmux for usb0 drvvbus */
+static struct pinmux_config usb0_pin_mux[] = {
+	{"usb0_drvvbus.usb0_drvvbus",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"mcasp0_ahclkr.gpio3_17",	OMAP_MUX_MODE7 | AM33XX_PULL_ENBL |
+					AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ben1.gpio1_28",		OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+/* pinmux for usb1 drvvbus */
+static struct pinmux_config usb1_pin_mux[] = {
+	{"usb1_drvvbus.usb1_drvvbus",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"mcasp0_aclkr.gpio3_18",	OMAP_MUX_MODE7 | AM33XX_PULL_ENBL |
+					AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* Module pin mux for rmii1 */
+static struct pinmux_config rmii1_pin_mux[] = {
+	{"mii1_crs.rmii1_crs_dv", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_rxerr.rmii1_rxerr", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_txen.rmii1_txen", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"mii1_txd1.rmii1_txd1", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"mii1_txd0.rmii1_txd0", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"mii1_rxd1.rmii1_rxd1", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_rxd0.rmii1_rxd0", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"rmii1_refclk.rmii1_refclk", OMAP_MUX_MODE0 |
+					AM33XX_PIN_INPUT_PULLDOWN},
+	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
+	{NULL, 0},
+};
+
+static struct at24_platform_data am335x_baseboard_eeprom_info = {
+	.byte_len       = 4096,
+	.page_size      = 32,
+	.flags          = AT24_FLAG_ADDR16,
+};
+
+static struct gpmc_timings am335x_nand_timings = {
+
+/* granularity of 10 is sufficient because of calculations */
+	.sync_clk = 0,
+
+	.cs_on = 0,
+	.cs_rd_off = 30,
+	.cs_wr_off = 30,
+
+	.adv_on = 0,
+	.adv_rd_off = 30,
+	.adv_wr_off = 30,
+
+	.oe_on = 10,
+	.we_off = 20,
+	.oe_off = 30,
+
+	.access = 30,
+	.rd_cycle = 30,
+	.wr_cycle = 30,
+
+	.cs_cycle_delay = 50,
+	.cs_delay_en = 1,
+	.wr_access = 30,
+	.wr_data_mux_bus = 0,
+};
+
+static struct stmpe_gpio_platform_data pba_gpio_stm_data = {
+	.gpio_base = -1,
+	.norequest_mask = STMPE_GPIO_NOREQ_811_TOUCH,
+};
+
+static struct stmpe_ts_platform_data pba_ts_stm_pdata = {
+	.sample_time = 4,
+	.mod_12b = 1,
+	.ref_sel = 0,
+	.adc_freq = 1,
+	.ave_ctrl = 3,
+	.touch_det_delay = 3,
+	.settling = 3,
+	.fraction_z = 7,
+	.i_drive = 0,
+};
+
+static struct stmpe_platform_data pba_stm_pdata = {
+	.blocks = STMPE_BLOCK_GPIO | STMPE_BLOCK_TOUCHSCREEN,
+	.irq_base = TWL4030_IRQ_END,
+	.irq_trigger = IRQF_TRIGGER_RISING,
+	.irq_invert_polarity = true,
+	.gpio = &pba_gpio_stm_data,
+	.ts = &pba_ts_stm_pdata,
+};
+
+#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || \
+	defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+static struct edt_ft5x06_platform_data pba_ft5x06_data = {
+	.reset_pin	= -1,		/* static high */
+	.irq_pin	= AM335X_PHYCARD_EDT_FT5X06_GPIO_IRQ,
+};
+#endif
+
+static void pcaaxs1_nand_init(void)
+{
+	struct omap_nand_platform_data *pdata;
+	struct gpmc_devices_info gpmc_device[2] = {
+		{ NULL, 0 },
+		{ NULL, 0 },
+	};
+
+	setup_pin_mux(nand_pin_mux);
+	pdata = omap_nand_init(NULL, 0, 0, 0, &am335x_nand_timings);
+	if (!pdata)
+		return;
+	pdata->ecc_opt = OMAP_ECC_BCH8_CODE_HW;
+	pdata->elm_used = true;
+	gpmc_device[0].pdata = pdata;
+	gpmc_device[0].flag = GPMC_DEVICE_NAND;
+
+	omap_init_gpmc(gpmc_device, sizeof(gpmc_device));
+	omap_init_elm();
+}
+
+static struct regulator_init_data am335x_dummy = {
+	.constraints.always_on  = true,
+};
+
+static struct regulator_consumer_supply am335x_vdd1_supply[] = {
+	REGULATOR_SUPPLY("vdd_mpu", NULL),
+};
+
+static struct regulator_init_data am335x_vdd1 = {
+	.constraints = {
+		.min_uV                 = 600000,
+		.max_uV                 = 1500000,
+		.valid_modes_mask       = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask         = REGULATOR_CHANGE_VOLTAGE,
+		.always_on              = 1,
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(am335x_vdd1_supply),
+	.consumer_supplies      = am335x_vdd1_supply,
+};
+
+static struct tps65910_board am335x_tps65910_info = {
+	.tps65910_pmic_init_data[TPS65910_REG_VRTC]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VIO]      = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD1]     = &am335x_vdd1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD2]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD3]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG1]    = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG2]    = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VPLL]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDAC]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX1]    = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX2]    = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX33]   = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VMMC]     = &am335x_dummy,
+};
+
+static void __init tps65910_rtc_irq_init(void)
+{
+
+	setup_pin_mux(rtc_pin_mux);
+
+	/* RTC in the TPS65910 PMIC */
+	if (omap_mux_init_signal("gpmc_a3.gpio1_19", AM33XX_PIN_INPUT_PULLUP))
+		printk(KERN_WARNING "Failed to mux PMIC IRQ\n");
+	else if (gpio_request_one(GPIO_RTC_PMIC_IRQ,
+			GPIOF_IN, "rtc-tps65910-irq") < 0)
+		printk(KERN_WARNING "failed to request GPIO%d\n",
+			GPIO_RTC_PMIC_IRQ);
+	else
+		am335x_tps65910_info.irq = gpio_to_irq(GPIO_RTC_PMIC_IRQ);
+}
+
+static struct pca9532_platform_data pcaaxs1_pca9530 = {
+	.leds = {
+		{
+			.name = "lcd_brightnes",
+			.state = PCA9532_OFF,
+			.type = PCA9532_TYPE_LED,
+		}, {
+			.name = "led_yellow",
+			.state = PCA9532_OFF,
+			.type = PCA9532_TYPE_LED,
+		},
+	},
+	.psc = { 1, 1 },
+	.pwm = { 1, 1 },
+};
+
+static struct i2c_board_info __initdata pcaaxs1_i2c0_boardinfo[] = {
+	{
+		I2C_BOARD_INFO("tps65910", TPS65910_I2C_ID1),
+		.platform_data  = &am335x_tps65910_info,
+	}, {
+		/* Baseboard board EEPROM */
+		I2C_BOARD_INFO("at24", EEPROM_I2C_ADDR),
+		.platform_data  = &am335x_baseboard_eeprom_info,
+	},
+};
+
+static struct i2c_board_info __initdata pcaaxs1_i2c1_boardinfo[] = {
+#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || \
+	defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+	{
+		I2C_BOARD_INFO("edt-ft5x06", 0x38),
+		.irq = OMAP_GPIO_IRQ(AM335X_PHYCARD_EDT_FT5X06_GPIO_IRQ),
+		.platform_data = &pba_ft5x06_data,
+	},
+#endif
+	{
+		I2C_BOARD_INFO("stmpe811", 0x44),
+		.irq = OMAP_GPIO_IRQ(AM335X_PHYCARD_STMPE811_GPIO_IRQ),
+		.platform_data = &pba_stm_pdata,
+	}, {
+		/* 2-Bit GPIO/PWM */
+		/* drivers/leds/leds-pca9530.c*/
+		I2C_BOARD_INFO("pca9530", 0x60),
+		.platform_data = &pcaaxs1_pca9530,
+	}, {
+		I2C_BOARD_INFO("rtc8564", 0x51),
+	},
+};
+
+static void __init pcaaxs1_i2c_init(void)
+{
+	setup_pin_mux(i2c0_pin_mux);
+	omap_register_i2c_bus(1, 100, pcaaxs1_i2c0_boardinfo,
+				ARRAY_SIZE(pcaaxs1_i2c0_boardinfo));
+	setup_pin_mux(i2c1_pin_mux);
+	omap_register_i2c_bus(2, 100, pcaaxs1_i2c1_boardinfo,
+				ARRAY_SIZE(pcaaxs1_i2c1_boardinfo));
+}
+
+static void tsc_init(void)
+{
+	setup_pin_mux(ts_irq_mux);
+	setup_pin_mux(tsc_pin_mux);
+}
+
+static int __init conf_disp_pll(int rate)
+{
+	struct clk *disp_pll;
+	int ret = -EINVAL;
+
+	disp_pll = clk_get(NULL, "dpll_disp_ck");
+	if (IS_ERR(disp_pll)) {
+		pr_err("Cannot clk_get disp_pll\n");
+		goto out;
+	}
+
+	ret = clk_set_rate(disp_pll, rate);
+	clk_put(disp_pll);
+out:
+	return ret;
+}
+
+static void lcdc_init(void)
+{
+	int ret;
+
+	setup_pin_mux(lcdc_pin_mux);
+
+	if (conf_disp_pll(300000000)) {
+		pr_info("Failed configure display PLL, not attempting to"
+				"register LCDC\n");
+	return;
+	}
+
+	if (am33xx_register_lcdc(&lcdc_selection_pdata))
+		pr_info("Failed to register LCDC device\n");
+
+	ret = gpio_request(GPIO_TO_PIN(1, 17), "DISPLAY_PWRDN");
+	if (ret < 0)
+		pr_warn("Failed to request gpio for DISPLAY_PWRDN\n");
+
+	return;
+}
+
+static struct omap_musb_board_data musb_board_data = {
+	.interface_type = MUSB_INTERFACE_ULPI,
+	/*
+	* mode[0:3] = USB0PORT's mode
+	* mode[4:7] = USB1PORT's mode
+	* PCM051 has USB0 in OTG mode and USB1 in host mode.
+	*/
+	.mode		= (MUSB_HOST << 4) | MUSB_OTG,
+	.power		= 500,
+	.instances	= 1,
+};
+
+static void usb_init(void)
+{
+	int ret;
+
+	setup_pin_mux(usb0_pin_mux);
+	setup_pin_mux(usb1_pin_mux);
+
+	ret = gpio_request(GPIO_TO_PIN(1, 28), "USB_OTG_SELFPOWERED");
+	if (ret < 0)
+		pr_warn("Failed to request gpio for USB_OTG_SELFPOWERED\n");
+
+	gpio_direction_output(GPIO_TO_PIN(1, 28), 0);
+
+	usb_musb_init(&musb_board_data);
+	return;
+}
+
+static void rmii1_init(void)
+{
+	setup_pin_mux(rmii1_pin_mux);
+	am33xx_cpsw_init(AM33XX_CPSW_MODE_RMII, NULL, NULL);
+	return;
+}
+
+/* Enable clkout1 */
+static struct pinmux_config clkout1_pin_mux[] = {
+	{"xdma_event_intr0.clkout1", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+static void __init clkout1_enable(void)
+{
+	struct clk *ck_32;
+
+	ck_32 = clk_get(NULL, "clkout1_ck");
+	if (IS_ERR(ck_32)) {
+		pr_err("Cannot clk_get ck_32\n");
+		return;
+	}
+
+	clk_enable(ck_32);
+
+	setup_pin_mux(clkout1_pin_mux);
+}
+
+static void mmc0_init(void)
+{
+	setup_pin_mux(mmc0_pin_mux);
+
+	omap2_hsmmc_init(am335x_mmc);
+	return;
+}
+
+static struct resource am33xx_cpuidle_resources[] = {
+	{
+		.start		= AM33XX_EMIF0_BASE,
+		.end		= AM33XX_EMIF0_BASE + SZ_32K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+/* AM33XX devices support DDR2 power down */
+static struct am33xx_cpuidle_config am33xx_cpuidle_pdata = {
+	.ddr2_pdown	= 1,
+};
+
+static struct platform_device am33xx_cpuidle_device = {
+	.name			= "cpuidle-am33xx",
+	.num_resources		= ARRAY_SIZE(am33xx_cpuidle_resources),
+	.resource		= am33xx_cpuidle_resources,
+	.dev = {
+		.platform_data	= &am33xx_cpuidle_pdata,
+	},
+};
+
+static void __init am33xx_cpuidle_init(void)
+{
+	int ret;
+
+	am33xx_cpuidle_pdata.emif_base = am33xx_get_mem_ctlr();
+
+	ret = platform_device_register(&am33xx_cpuidle_device);
+
+	if (ret)
+		pr_warning("AM33XX cpuidle registration failed\n");
+
+}
+
+static void __init pcaaxs1_init(void)
+{
+	am33xx_cpuidle_init();
+	am33xx_mux_init(NULL);
+	omap_serial_init();
+	clkout1_enable();
+	tps65910_rtc_irq_init();
+	tsc_init();
+	pcaaxs1_i2c_init();
+	omap_sdrc_init(NULL, NULL);
+	/* Create an alias for icss clock */
+	if (clk_add_alias("pruss", NULL, "pruss_uart_gclk", NULL))
+		pr_warn("failed to create an alias: pruss_uart_gclk --> pruss\n");
+	/* Create an alias for gfx/sgx clock */
+	if (clk_add_alias("sgx_ck", NULL, "gfx_fclk", NULL))
+		pr_warn("failed to create an alias: gfx_fclk --> sgx_ck\n");
+	mmc0_init();
+	lcdc_init();
+	pcaaxs1_nand_init();
+	usb_init();
+	rmii1_init();
+}
+
+static void __init pcaaxs1_map_io(void)
+{
+	omap2_set_globals_am33xx();
+	omapam33xx_map_common_io();
+}
+
+MACHINE_START(PCAAXS1, "pcaaxs1")
+	/* Maintainer: PHYTEC */
+	.atag_offset	= 0x100,
+	.map_io		= pcaaxs1_map_io,
+	.init_early	= am33xx_init_early,
+	.init_irq	= ti81xx_init_irq,
+	.handle_irq     = omap3_intc_handle_irq,
+	.timer		= &omap3_am33xx_timer,
+	.init_machine	= pcaaxs1_init,
+MACHINE_END
diff --git a/arch/arm/mach-omap2/board-pcm051.c b/arch/arm/mach-omap2/board-pcm051.c
new file mode 100644
index 0000000..3ff45c6
--- /dev/null
+++ b/arch/arm/mach-omap2/board-pcm051.c
@@ -0,0 +1,1160 @@
+/*
+ * Code for AM335X EVM.
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/i2c/at24.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/input/matrix_keypad.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/wl12xx.h>
+#include <linux/ethtool.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/mfd/tps65217.h>
+#include <linux/pwm_backlight.h>
+#include <linux/input/ti_tsc.h>
+#include <linux/input/edt-ft5x06.h>
+#include <linux/platform_data/ti_adc.h>
+#include <linux/mfd/ti_tscadc.h>
+#include <linux/reboot.h>
+#include <linux/pwm/pwm.h>
+#include <linux/opp.h>
+#include <linux/micrel_phy.h>
+
+/* LCD controller is similar to DA850 */
+#include <video/da8xx-fb.h>
+
+#include <mach/hardware.h>
+#include <mach/board-pcm051.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/hardware/asp.h>
+
+#include <plat/omap_device.h>
+#include <plat/irqs.h>
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/lcdc.h>
+#include <plat/usb.h>
+#include <plat/mmc.h>
+#include <plat/emif.h>
+#include <plat/nand.h>
+
+#include "board-flash.h"
+#include "cpuidle33xx.h"
+#include "mux.h"
+#include "devices.h"
+#include "hsmmc.h"
+#include "am33xx_generic.h"
+
+#define AM335X_PHYCORE_EDT_FT5X06_GPIO_IRQ GPIO_TO_PIN(0, 20)
+#define GPIO_RTC_RV4162C7_IRQ  GPIO_TO_PIN(0, 20)
+#define GPIO_RTC_PMIC_IRQ  GPIO_TO_PIN(3, 4)
+
+/* KSZ9021 PHY/MDIO REGS */
+#define KSZ9021_EXTCTRL		0xB
+#define KSZ9021_EXTWR		0xC
+#define KSZ9021_EXTRD		0xD
+#define KSZ9021_WRBIT		BIT(15)
+
+#define KSZ9021_CLKSKEW		0x104
+#define KSZ9021_CLKSKEW_VAL	0x7070
+
+#define KSZ9021_RXSKEW         0x105
+#define KSZ9021_RXSKEW_VAL     0x0000
+
+#define KSZ9021_TXSKEW         0x106
+#define KSZ9021_TXSKEW_VAL     0x0000
+
+/* Convert GPIO signal to GPIO pin number */
+#define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
+
+static const struct display_panel disp_panel = {
+	WVGA,
+	32,
+	32,
+	COLOR_ACTIVE,
+};
+
+/* LCD backlight platform Data */
+#define AM335X_BACKLIGHT_MAX_BRIGHTNESS        100
+#define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    100
+#define AM335X_PWM_PERIOD_NANO_SECONDS         100000
+
+#define PWM_DEVICE_ID   "ecap.0"
+
+static struct platform_pwm_backlight_data am335x_backlight_data = {
+	.pwm_id         = PWM_DEVICE_ID,
+	.ch             = -1,
+	.max_brightness = AM335X_BACKLIGHT_MAX_BRIGHTNESS,
+	.dft_brightness = AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS,
+	.pwm_period_ns  = AM335X_PWM_PERIOD_NANO_SECONDS,
+};
+
+static struct lcd_ctrl_config lcd_cfg = {
+	&disp_panel,
+	.ac_bias		= 40,
+	.ac_bias_intrpt		= 0,
+	.dma_burst_sz		= 16,
+	.bpp			= 32,
+	.fdd			= 0x80,
+	.tft_alt_mode		= 0,
+	.stn_565_mode		= 0,
+	.mono_8bit_mode		= 0,
+	.invert_line_clock	= 1,
+	.invert_frm_clock	= 1,
+	.sync_edge		= 0,
+	.sync_ctrl		= 1,
+	.raster_order		= 0,
+};
+
+static struct da8xx_lcdc_platform_data lcdc_pdata[] = {
+#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || \
+	defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+	{
+		.manu_name		= "Emerging",
+		.controller_data	= &lcd_cfg,
+		.type			= "ETM0700G0DH6",
+	},
+#endif
+	{
+		.manu_name		= "PrimeView",
+		.controller_data	= &lcd_cfg,
+		.type			= "PV_PM070WL4",
+	}, {
+		.manu_name		= "PrimeView",
+		.controller_data	= &lcd_cfg,
+		.type			= "PV_PD035VL1",
+	}, {
+		.manu_name		= "PrimeView",
+		.controller_data	= &lcd_cfg,
+		.type			= "PV_PD050VL1",
+	}, {
+		.manu_name		= "PrimeView",
+		.controller_data	= &lcd_cfg,
+		.type			= "PV_PD104SLF",
+	}
+};
+
+static struct da8xx_lcdc_selection_platform_data lcdc_selection_pdata = {
+	.entries_ptr = lcdc_pdata,
+	.entries_cnt = ARRAY_SIZE(lcdc_pdata)
+};
+
+#include "common.h"
+
+/* TSc controller */
+#include <linux/lis3lv02d.h>
+
+static struct tsc_data am335x_touchscreen_data  = {
+	.wires  = 4,
+	.x_plate_resistance = 200,
+	.steps_to_configure = 5,
+};
+
+static struct adc_data am335x_adc_data = {
+	.adc_channels = 4,
+};
+
+static struct mfd_tscadc_board tscadc = {
+	.tsc_init = &am335x_touchscreen_data,
+	.adc_init = &am335x_adc_data,
+};
+
+static u8 am335x_iis_serializer_direction0[] = {
+	RX_MODE,	TX_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+};
+
+static struct snd_platform_data pcm051_snd_data0 = {
+	.tx_dma_offset  = 0x46000000,   /* McASP0 */
+	.rx_dma_offset  = 0x46000000,
+	.op_mode        = DAVINCI_MCASP_IIS_MODE,
+	.num_serializer = ARRAY_SIZE(am335x_iis_serializer_direction0),
+	.tdm_slots      = 2,
+	.serial_dir     = am335x_iis_serializer_direction0,
+	.asp_chan_q     = EVENTQ_2, /* davinci-mcsap driver does not use it */
+	.version        = MCASP_VERSION_3,
+	.txnumevt       = 1,
+	.rxnumevt       = 1,
+};
+
+static struct omap2_hsmmc_info am335x_mmc[] __initdata = {
+	{
+		.mmc            = 1,
+		.caps           = MMC_CAP_4_BIT_DATA,
+		.gpio_cd        = GPIO_TO_PIN(0, 6),
+		.gpio_wp	= -EINVAL,
+		.ocr_mask       = MMC_VDD_32_33 | MMC_VDD_33_34, /* 3V3 */
+	},
+	{
+		.mmc            = 0,	/* will be set at runtime */
+	},
+	{
+		.mmc            = 0,	/* will be set at runtime */
+	},
+	{}      /* Terminator */
+};
+
+
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+	AM33XX_MUX(I2C0_SDA, OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
+			AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT),
+	AM33XX_MUX(I2C0_SCL, OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
+			AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define	board_mux	NULL
+#endif
+
+/* module pin mux structure */
+struct pinmux_config {
+	const char *string_name; /* signal name format */
+	int val; /* Options for the mux register value */
+};
+
+/* Module pin mux for LCDC */
+static struct pinmux_config lcdc_pin_mux[] = {
+	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data1.lcd_data1",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data2.lcd_data2",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data3.lcd_data3",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data4.lcd_data4",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data5.lcd_data5",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data6.lcd_data6",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data7.lcd_data7",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data8.lcd_data8",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data9.lcd_data9",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data10.lcd_data10",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data11.lcd_data11",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data12.lcd_data12",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data13.lcd_data13",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data14.lcd_data14",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"lcd_data15.lcd_data15",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+						       | AM33XX_PULL_DISA},
+	{"gpmc_ad8.lcd_data16",		OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad9.lcd_data17",		OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad10.lcd_data18",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad11.lcd_data19",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad12.lcd_data20",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad13.lcd_data21",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad14.lcd_data22",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad15.lcd_data23",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"lcd_vsync.lcd_vsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_hsync.lcd_hsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_pclk.lcd_pclk",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+/* Pin mux for nand flash module */
+static struct pinmux_config nand_pin_mux[] = {
+	{"gpmc_ad0.gpmc_ad0",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad1.gpmc_ad1",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad2.gpmc_ad2",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad3.gpmc_ad3",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad4.gpmc_ad4",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad5.gpmc_ad5",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad6.gpmc_ad6",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad7.gpmc_ad7",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_wait0.gpmc_wait0", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_wpn.gpmc_wpn",	  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_csn0.gpmc_csn0",	  OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_advn_ale.gpmc_advn_ale",  OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_oen_ren.gpmc_oen_ren",	 OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_wen.gpmc_wen",     OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_ben0_cle.gpmc_ben0_cle",	 OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{NULL, 0},
+};
+
+/* Module pin mux for SPI fash */
+static struct pinmux_config spi0_pin_mux[] = {
+	{"spi0_sclk.spi0_sclk", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL
+							| AM33XX_INPUT_EN},
+	{"spi0_d0.spi0_d0", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL | AM33XX_PULL_UP
+							| AM33XX_INPUT_EN},
+	{"spi0_d1.spi0_d1", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL
+							| AM33XX_INPUT_EN},
+	{"spi0_cs0.spi0_cs0", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL | AM33XX_PULL_UP
+							| AM33XX_INPUT_EN},
+	{NULL, 0},
+};
+
+/* Module pin mux for rgmii2 */
+static struct pinmux_config rgmii2_pin_mux[] = {
+	{"gpmc_a0.rgmii2_tctl", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a1.rgmii2_rctl", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a2.rgmii2_td3", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a3.rgmii2_td2", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a4.rgmii2_td1", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a5.rgmii2_td0", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a6.rgmii2_tclk", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a7.rgmii2_rclk", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a8.rgmii2_rd3", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a9.rgmii2_rd2", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a10.rgmii2_rd1", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a11.rgmii2_rd0", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* Module pin mux for rmii1 */
+static struct pinmux_config rmii1_pin_mux[] = {
+	{"mii1_crs.rmii1_crs_dv", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_rxerr.mii1_rxerr", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_txen.mii1_txen", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"mii1_txd1.mii1_txd1", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"mii1_txd0.mii1_txd0", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"mii1_rxd1.mii1_rxd1", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_rxd0.mii1_rxd0", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"rmii1_refclk.rmii1_refclk", OMAP_MUX_MODE0 |
+					AM33XX_PIN_INPUT_PULLDOWN},
+	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* Module pin mux for mcasp0 */
+static struct pinmux_config mcasp0_pin_mux[] = {
+	{"mcasp0_aclkx.mcasp0_aclkx", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"mcasp0_fsx.mcasp0_fsx", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"mcasp0_axr0.mcasp0_axr0", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mcasp0_axr1.mcasp0_axr1", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"mcasp0_ahclkx.mcasp0_ahclkx", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+/* Module pin mux for mmc0 */
+static struct pinmux_config mmc0_pin_mux[] = {
+	{"mmc0_dat3.mmc0_dat3",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat2.mmc0_dat2",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat1.mmc0_dat1",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat0.mmc0_dat0",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_clk.mmc0_clk",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_cmd.mmc0_cmd",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"spi0_cs1.mmc0_sdcd",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* Module pin mux for uart2 */
+static struct pinmux_config uart2_pin_mux[] = {
+	{"mii1_txclk.uart2_rxd_mux0", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"mii1_rxclk.uart2_txd_mux0", OMAP_MUX_MODE1 | AM33XX_PULL_ENBL},
+	{NULL, 0},
+};
+
+/* Module pin mux for uart3 */
+static struct pinmux_config uart3_pin_mux[] = {
+	{"mii1_rxd3.uart3_rxd_mux0", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"mii1_rxd2.uart3_txd_mux0", OMAP_MUX_MODE1 | AM33XX_PULL_ENBL},
+	{NULL, 0},
+};
+
+static struct pinmux_config d_can1_pin_mux[] = {
+	{"uart1_txd.dcan1_rx_mux2", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
+	{"uart1_rxd.dcan1_tx_mux2", OMAP_MUX_MODE2 | AM33XX_PULL_ENBL},
+	{NULL, 0},
+};
+
+/* pin mux for connectivity muxing on carrier board */
+static struct pinmux_config cbmux_gpio_pin_mux[] = {
+	{"uart0_ctsn.d_can1_tx", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{"uart0_rtsn.d_can1_rx", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{"emu0.gpio3_7", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{"emu1.gpio3_8", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+
+/*
+* @pin_mux - single module pin-mux structure which defines pin-mux
+*			details for all its pins.
+*/
+static void setup_pin_mux(struct pinmux_config *pin_mux)
+{
+	int i;
+
+	for (i = 0; pin_mux->string_name != NULL; pin_mux++)
+		omap_mux_init_signal(pin_mux->string_name, pin_mux->val);
+
+}
+
+/* pinmux for usb0 drvvbus */
+static struct pinmux_config usb0_pin_mux[] = {
+	{"usb0_drvvbus.usb0_drvvbus",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"mcasp0_ahclkr.gpio3_17",	OMAP_MUX_MODE7 | AM33XX_PULL_ENBL |
+					AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* pinmux for usb1 drvvbus */
+static struct pinmux_config usb1_pin_mux[] = {
+	{"usb1_drvvbus.usb1_drvvbus",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"mcasp0_aclkr.gpio3_18",	OMAP_MUX_MODE7 | AM33XX_PULL_ENBL |
+					AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* Module pin mux for eCAP0 */
+static struct pinmux_config ecap0_pin_mux[] = {
+	{"ecap0_in_pwm0_out.ecap0_in_pwm0_out",
+		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+#define PCM051_WLAN_IRQ_GPIO	GPIO_TO_PIN(1, 25)
+#define PCM051_WLAN_EN		GPIO_TO_PIN(1, 24)
+#define PCM051_BT_EN		GPIO_TO_PIN(1, 22)
+
+struct wl12xx_platform_data pcm051_wlan_data = {
+	.irq = OMAP_GPIO_IRQ(PCM051_WLAN_IRQ_GPIO),
+	.board_ref_clock = WL12XX_REFCLOCK_38_XTAL, /* 38.4Mhz */
+	.bt_enable_gpio = PCM051_BT_EN,
+	.wlan_enable_gpio = PCM051_WLAN_EN,
+};
+
+/* Module pin mux for wlan and bluetooth */
+static struct pinmux_config mmc2_wl12xx_pin_mux[] = {
+	{"gpmc_a1.mmc2_dat0", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_a2.mmc2_dat1", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_a3.mmc2_dat2", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ben1.mmc2_dat3", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_csn3.mmc2_cmd", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_clk.mmc2_clk", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+static struct pinmux_config uart1_wl12xx_pin_mux[] = {
+	{"uart1_ctsn.uart1_ctsn", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"uart1_rtsn.uart1_rtsn", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT},
+	{"uart1_rxd.uart1_rxd", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"uart1_txd.uart1_txd", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL},
+	{NULL, 0},
+};
+
+static struct pinmux_config wl12xx_pin_mux[] = {
+	{"gpmc_a6.gpio1_22", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT_PULLUP},
+	{"gpmc_a8.gpio1_24", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a9.gpio1_25", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
+	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
+	{NULL, 0},
+};
+
+static int backlight_enable;
+
+static void enable_ecap0(void)
+{
+	backlight_enable = 1;
+	setup_pin_mux(ecap0_pin_mux);
+}
+
+#define PCM051_CBMUX_JP3_PIN    GPIO_TO_PIN(1, 8)
+#define PCM051_CBMUX_JP4_PIN    GPIO_TO_PIN(1, 9)
+
+/* Setup pwm-backlight */
+static struct platform_device am335x_backlight = {
+	.name           = "pwm-backlight",
+	.id             = -1,
+	.dev            = {
+		.platform_data  = &am335x_backlight_data,
+	}
+};
+
+static struct pwmss_platform_data pwm_pdata = {
+	.version = PWM_VERSION_1
+};
+
+static int __init ecap0_init(void)
+{
+	if (backlight_enable) {
+		am33xx_register_ecap(0, &pwm_pdata);
+		platform_device_register(&am335x_backlight);
+	}
+
+	return 0;
+}
+late_initcall(ecap0_init);
+
+static int __init conf_disp_pll(int rate)
+{
+	struct clk *disp_pll;
+	int ret = -EINVAL;
+
+	disp_pll = clk_get(NULL, "dpll_disp_ck");
+	if (IS_ERR(disp_pll)) {
+		pr_err("Cannot clk_get disp_pll\n");
+		goto out;
+	}
+
+	ret = clk_set_rate(disp_pll, rate);
+	clk_put(disp_pll);
+out:
+	return ret;
+}
+
+static void lcdc_init(void)
+{
+
+	setup_pin_mux(lcdc_pin_mux);
+
+	if (conf_disp_pll(300000000)) {
+		pr_info("Failed configure display PLL, not attempting to"
+				"register LCDC\n");
+		return;
+	}
+
+	if (am33xx_register_lcdc(&lcdc_selection_pdata))
+		pr_info("Failed to register LCDC device\n");
+	return;
+}
+
+static void tsc_init(void)
+{
+	int err;
+
+	err = am33xx_register_mfd_tscadc(&tscadc);
+	if (err)
+		pr_err("failed to register touchscreen device\n");
+}
+
+static void rgmii2_init(void)
+{
+	setup_pin_mux(rgmii2_pin_mux);
+	return;
+}
+
+static void rmii1_init(void)
+{
+	setup_pin_mux(rmii1_pin_mux);
+	return;
+}
+
+static void usb0_init(void)
+{
+	setup_pin_mux(usb0_pin_mux);
+	return;
+}
+
+static void usb1_init(void)
+{
+	setup_pin_mux(usb1_pin_mux);
+	return;
+}
+
+/* setup uart3 */
+static void uart3_init(void)
+{
+	setup_pin_mux(uart3_pin_mux);
+	return;
+}
+
+/* setup uart2 */
+static void uart2_init(void)
+{
+	setup_pin_mux(uart2_pin_mux);
+	return;
+}
+
+static void cbmux_gpio_init(void)
+{
+	setup_pin_mux(cbmux_gpio_pin_mux);
+	return;
+}
+
+static const struct flash_platform_data am335x_spi_flash = {
+	.type      = "w25q64",
+	.name      = "spi_flash",
+};
+
+/*
+ * SPI Flash works at 80Mhz however SPI Controller works at 48MHz.
+ * So setup Max speed to be less than that of Controller speed
+ */
+static struct spi_board_info am335x_spi0_slave_info[] = {
+	{
+		.modalias      = "m25p80",
+		.platform_data = &am335x_spi_flash,
+		.irq           = -1,
+		.max_speed_hz  = 24000000,
+		.bus_num       = 1,
+		.chip_select   = 0,
+	},
+};
+
+static struct gpmc_timings am335x_nand_timings = {
+
+	/* granularity of 10 is sufficient because of calculations */
+	.sync_clk = 0,
+
+	.cs_on = 0,
+	.cs_rd_off = 30,
+	.cs_wr_off = 30,
+
+	.adv_on = 0,
+	.adv_rd_off = 30,
+	.adv_wr_off = 30,
+
+	.oe_on = 10,
+	.we_off = 20,
+	.oe_off = 30,
+
+	.access = 30,
+	.rd_cycle = 30,
+	.wr_cycle = 30,
+
+	.cs_cycle_delay = 50,
+	.cs_delay_en = 1,
+	.wr_access = 30,
+	.wr_data_mux_bus = 0,
+};
+
+static void pcm051_nand_init(void)
+{
+	struct omap_nand_platform_data *pdata;
+	struct gpmc_devices_info gpmc_device[2] = {
+		{ NULL, 0 },
+		{ NULL, 0 },
+	};
+
+	setup_pin_mux(nand_pin_mux);
+	pdata = omap_nand_init(NULL, 0, 0, 0, &am335x_nand_timings);
+	if (!pdata)
+		return;
+	pdata->ecc_opt = OMAP_ECC_BCH8_CODE_HW;
+	pdata->elm_used = true;
+	gpmc_device[0].pdata = pdata;
+	gpmc_device[0].flag = GPMC_DEVICE_NAND;
+
+	omap_init_gpmc(gpmc_device, sizeof(gpmc_device));
+	omap_init_elm();
+}
+
+static void mmc2_wl12xx_init(void)
+{
+	setup_pin_mux(mmc2_wl12xx_pin_mux);
+
+	am335x_mmc[1].mmc = 3;
+	am335x_mmc[1].name = "wl1271";
+	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD;
+	am335x_mmc[1].nonremovable = true;
+	am335x_mmc[1].gpio_cd = -EINVAL;
+	am335x_mmc[1].gpio_wp = -EINVAL;
+/*	am335x_mmc[1].ocr_mask = MMC_VDD_165_195; */ /* 1V8 */
+	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
+
+	/* mmc will be initialized when mmc0_init is called */
+	return;
+}
+
+static void uart1_wl12xx_init(void)
+{
+	setup_pin_mux(uart1_wl12xx_pin_mux);
+}
+
+static void wl12xx_bluetooth_enable(void)
+{
+	int status = gpio_request(pcm051_wlan_data.bt_enable_gpio,
+		"bt_en\n");
+	if (status < 0)
+		pr_err("Failed to request gpio for bt_enable");
+
+	pr_info("Configure Bluetooth Enable pin...\n");
+	gpio_direction_output(pcm051_wlan_data.bt_enable_gpio, 0);
+}
+
+static int wl12xx_set_power(struct device *dev, int slot, int on, int vdd)
+{
+	if (on) {
+		gpio_direction_output(pcm051_wlan_data.wlan_enable_gpio, 1);
+		mdelay(70);
+	} else {
+		gpio_direction_output(pcm051_wlan_data.wlan_enable_gpio, 0);
+	}
+
+	return 0;
+}
+
+static void wl12xx_init(void)
+{
+	struct device *dev;
+	struct omap_mmc_platform_data *pdata;
+	int ret;
+
+	setup_pin_mux(wl12xx_pin_mux);
+	wl12xx_bluetooth_enable();
+
+	if (wl12xx_set_platform_data(&pcm051_wlan_data))
+		pr_err("error setting wl12xx data\n");
+
+	dev = am335x_mmc[1].dev;
+	if (!dev) {
+		pr_err("wl12xx mmc device initialization failed\n");
+		goto out;
+	}
+
+	pdata = dev->platform_data;
+	if (!pdata) {
+		pr_err("Platfrom data of wl12xx device not set\n");
+		goto out;
+	}
+
+	ret = gpio_request_one(pcm051_wlan_data.wlan_enable_gpio,
+		GPIOF_OUT_INIT_LOW, "wlan_en");
+	if (ret) {
+		pr_err("Error requesting wlan enable gpio: %d\n", ret);
+		goto out;
+	}
+
+	pdata->slots[0].set_power = wl12xx_set_power;
+out:
+	return;
+}
+
+static void d_can_init(void)
+{
+	/* Instance Zero */
+	setup_pin_mux(d_can1_pin_mux);
+	am33xx_d_can_init(1);
+}
+
+static void mmc0_init(void)
+{
+	setup_pin_mux(mmc0_pin_mux);
+
+	omap2_hsmmc_init(am335x_mmc);
+	return;
+}
+
+/* setup spi0 */
+static void spi0_init(void)
+{
+	setup_pin_mux(spi0_pin_mux);
+	spi_register_board_info(am335x_spi0_slave_info,
+			ARRAY_SIZE(am335x_spi0_slave_info));
+	return;
+}
+
+#define CBMUX_VAL 2
+static void set_pcm051_cbmux_gpios(int jp4, int jp3)
+{
+	int status = 0;
+
+	pr_info("Setting JP3\n");
+	status = gpio_request(PCM051_CBMUX_JP3_PIN, "jp3\n");
+		if (status < 0)
+			pr_warn("Failed to request gpio for JP3\n");
+	gpio_direction_output(PCM051_CBMUX_JP3_PIN, jp3);
+
+	pr_info("Setting JP4\n");
+	status = gpio_request(PCM051_CBMUX_JP4_PIN, "jp4\n");
+		if (status < 0)
+			pr_warn("Failed to request gpio for JP4\n");
+	gpio_direction_output(PCM051_CBMUX_JP4_PIN, jp4);
+
+	return;
+}
+
+static void pcm051_mux_dev_cfg(int mux_val)
+{
+	switch (mux_val) {
+	case 1:
+		enable_ecap0();
+		cbmux_gpio_init();
+		d_can_init();
+		lcdc_init();
+		tsc_init();
+		mmc2_wl12xx_init();
+		mmc0_init();
+		uart1_wl12xx_init();
+		wl12xx_init();
+		break;
+	case 2:
+		enable_ecap0();
+		cbmux_gpio_init();
+		d_can_init();
+		lcdc_init();
+		tsc_init();
+		rmii1_init();
+		mmc0_init();
+		rgmii2_init();
+		break;
+	default:
+		pr_info("Other configurations have not been implemented\n");
+	}
+
+	usb0_init();
+	usb1_init();
+	uart2_init();
+	uart3_init();
+	pcm051_nand_init();
+	spi0_init();
+
+	return;
+}
+
+static void pcm051_mux_init(void)
+{
+	pr_info("The board is a PCM051 phyCORE-AM335x\n");
+
+	/* Choose mux settings based on the MUX on
+	 * the carrier board associated with JP3 and JP4 */
+	if (0 == CBMUX_VAL) {
+		pr_info("Muxing pins with CBMUX_VAL = 0\n");
+		set_pcm051_cbmux_gpios(0, 0);
+	} else if (1 == CBMUX_VAL) {
+		pr_info("Muxing pins with CBMUX_VAL = 1\n");
+		set_pcm051_cbmux_gpios(0, 1);
+	} else if (2 == CBMUX_VAL) {
+		pr_info("Muxing pins with CBMUX_VAL = 2\n");
+		set_pcm051_cbmux_gpios(1, 0);
+	} else if (3 == CBMUX_VAL) {
+		pr_info("Muxing pins with CBMUX_VAL = 3\n");
+		set_pcm051_cbmux_gpios(1, 1);
+	} else {
+		pr_err("CBMUX_VAL is invalid. Using CBMUX_VAL = 2\n");
+		set_pcm051_cbmux_gpios(1, 0);
+	}
+
+	pcm051_mux_dev_cfg(CBMUX_VAL);
+}
+
+static int am335x_ksz9021_phy_fixup(struct phy_device *phydev)
+{
+	/* Set KSZ9021_CLKSKEW */
+	phy_write(phydev, KSZ9021_EXTCTRL, (KSZ9021_WRBIT | KSZ9021_CLKSKEW));
+	phy_write(phydev, KSZ9021_EXTWR, KSZ9021_CLKSKEW_VAL);
+
+	phy_write(phydev, KSZ9021_EXTCTRL, KSZ9021_CLKSKEW);
+	printk(KERN_INFO "CLKSKEW == 0x%x\n", (phy_read(phydev,
+					KSZ9021_EXTRD)));
+
+	/* Set KSZ9021_RXSKEW */
+	phy_write(phydev, KSZ9021_EXTCTRL, (KSZ9021_WRBIT | KSZ9021_RXSKEW));
+	phy_write(phydev, KSZ9021_EXTWR, KSZ9021_RXSKEW_VAL);
+
+	phy_write(phydev, KSZ9021_EXTCTRL, KSZ9021_RXSKEW);
+	printk(KERN_INFO "RXSKEW == 0x%x\n", (phy_read(phydev, KSZ9021_EXTRD)));
+
+	/* Set KSZ9021_TXSKEW */
+	phy_write(phydev, KSZ9021_EXTCTRL, (KSZ9021_WRBIT | KSZ9021_TXSKEW));
+	phy_write(phydev, KSZ9021_EXTWR, KSZ9021_TXSKEW_VAL);
+
+	phy_write(phydev, KSZ9021_EXTCTRL, KSZ9021_TXSKEW);
+	printk(KERN_INFO "TXSKEW == 0x%x\n", (phy_read(phydev, KSZ9021_EXTRD)));
+
+	return 0;
+}
+
+#define PHY_ISOLATE BIT(10)
+
+static int am335x_disable_phy(struct phy_device *phydev)
+{
+	phy_write(phydev, 0x0, PHY_ISOLATE);
+
+	return 0;
+}
+
+static void pcm051_setup(struct memory_accessor *mem_acc, void *context)
+{
+	switch (CBMUX_VAL) {
+	case 1:
+		am33xx_cpsw_init(AM33XX_CPSW_MODE_MII, NULL, NULL);
+		phy_register_fixup(PHY_ANY_ID, PHY_ANY_UID, 0xffffffff,
+					am335x_disable_phy);
+		break;
+	case 2:
+		am33xx_cpsw_init(AM33XX_CPSW_MODE_RMII1_RGMII2, NULL, NULL);
+		phy_register_fixup_for_uid(PHY_ID_KSZ9021, 0x000ffffe,
+						am335x_ksz9021_phy_fixup);
+	default:
+		break;
+	}
+
+	return;
+}
+
+static struct at24_platform_data am335x_baseboard_eeprom_info = {
+	.byte_len       = (32*1024) / 8,
+	.page_size      = 32,
+	.flags          = AT24_FLAG_ADDR16,
+	.setup          = pcm051_setup,
+	.context        = (void *)NULL,
+};
+
+static struct regulator_init_data am335x_dummy = {
+	.constraints.always_on	= true,
+};
+
+static struct regulator_consumer_supply am335x_vdd1_supply[] = {
+	REGULATOR_SUPPLY("vdd_mpu", NULL),
+};
+
+static struct regulator_init_data am335x_vdd1 = {
+	.constraints = {
+		.min_uV			= 600000,
+		.max_uV			= 1500000,
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE,
+		.always_on		= 1,
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(am335x_vdd1_supply),
+	.consumer_supplies	= am335x_vdd1_supply,
+};
+
+static struct tps65910_board am335x_tps65910_info = {
+	.tps65910_pmic_init_data[TPS65910_REG_VRTC]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VIO]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD1]	= &am335x_vdd1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD2]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD3]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG1]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG2]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VPLL]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDAC]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX1]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX2]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX33]	= &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VMMC]	= &am335x_dummy,
+	.irq				= OMAP_GPIO_IRQ(GPIO_RTC_PMIC_IRQ),
+};
+
+#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || \
+		defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+static struct edt_ft5x06_platform_data pba_ft5x06_data = {
+	.reset_pin      = -1,		/* static high */
+	.irq_pin        = AM335X_PHYCORE_EDT_FT5X06_GPIO_IRQ,
+};
+#endif
+
+static struct i2c_board_info __initdata pcm051_i2c_boardinfo[] = {
+#if defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) || \
+		defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+	{
+		I2C_BOARD_INFO("edt-ft5x06", 0x38),
+		.irq = OMAP_GPIO_IRQ(AM335X_PHYCORE_EDT_FT5X06_GPIO_IRQ),
+		.platform_data = &pba_ft5x06_data,
+	},
+#endif
+	{
+		/* Baseboard board EEPROM */
+		I2C_BOARD_INFO("24c32", EEPROM_I2C_ADDR),
+		.platform_data  = &am335x_baseboard_eeprom_info,
+	},
+	{
+		I2C_BOARD_INFO("tps65910", TPS65910_I2C_ID1),
+		.platform_data  = &am335x_tps65910_info,
+	},
+	{
+		I2C_BOARD_INFO("rv4162c7", 0x68),
+#if !defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) && \
+		!defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+		.irq = OMAP_GPIO_IRQ(GPIO_RTC_RV4162C7_IRQ),
+#endif
+	},
+	{
+		I2C_BOARD_INFO("wm8974", 0x1a),
+	},
+};
+
+static struct omap_musb_board_data musb_board_data = {
+	.interface_type	= MUSB_INTERFACE_ULPI,
+	/*
+	 * mode[0:3] = USB0PORT's mode
+	 * mode[4:7] = USB1PORT's mode
+	 * PCM051 has USB0 in OTG mode and USB1 in host mode.
+	 */
+	.mode           = (MUSB_HOST << 4) | MUSB_OTG,
+	.power		= 500,
+	.instances	= 1,
+};
+
+static void __init pcm051_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 100, pcm051_i2c_boardinfo,
+				ARRAY_SIZE(pcm051_i2c_boardinfo));
+}
+
+/* Enable clkout1 */
+static struct pinmux_config clkout1_pin_mux[] = {
+	{"xdma_event_intr0.clkout1", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+static void __init clkout1_enable(void)
+{
+	struct clk *ck_32;
+
+	ck_32 = clk_get(NULL, "clkout1_ck");
+	if (IS_ERR(ck_32)) {
+		pr_err("Cannot clk_get ck_32\n");
+		return;
+	}
+
+	clk_enable(ck_32);
+
+	setup_pin_mux(clkout1_pin_mux);
+}
+
+static struct pinmux_config rtc_pin_mux[] = {
+	{"xdma_event_intr1.gpio0_20", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	/* gpio0_20 is shared by lcd touch irq and rtc irq */
+	{"mii1_rxdv.gpio3_4", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+static void __init pcm051_rtc_irq_init(void)
+{
+	int r;
+
+	setup_pin_mux(rtc_pin_mux);
+
+#if !defined(CONFIG_TOUCHSCREEN_EDT_FT5X06) && \
+		!defined(CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE)
+	/* Option 1: RV-4162 */
+	r = gpio_request_one(GPIO_RTC_RV4162C7_IRQ,
+				GPIOF_IN, "rtc-rv4162c7-irq");
+	if (r < 0) {
+		printk(KERN_WARNING "failed to request GPIO%d\n",
+				GPIO_RTC_RV4162C7_IRQ);
+		return;
+	}
+#endif
+
+	/* Option 2: RTC in the TPS65910 PMIC */
+	if (omap_mux_init_signal("mii1_rxdv.gpio3_4", AM33XX_PIN_INPUT_PULLUP))
+		printk(KERN_WARNING "Failed to mux PMIC IRQ\n");
+	else if (gpio_request_one(GPIO_RTC_PMIC_IRQ,
+				GPIOF_IN, "rtc-tps65910-irq") < 0)
+		printk(KERN_WARNING "failed to request GPIO%d\n",
+				GPIO_RTC_PMIC_IRQ);
+}
+
+static struct resource am33xx_cpuidle_resources[] = {
+	{
+		.start		= AM33XX_EMIF0_BASE,
+		.end		= AM33XX_EMIF0_BASE + SZ_32K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+/* AM33XX devices support DDR2 power down */
+static struct am33xx_cpuidle_config am33xx_cpuidle_pdata = {
+	.ddr2_pdown	= 1,
+};
+
+static struct platform_device am33xx_cpuidle_device = {
+	.name			= "cpuidle-am33xx",
+	.num_resources		= ARRAY_SIZE(am33xx_cpuidle_resources),
+	.resource		= am33xx_cpuidle_resources,
+	.dev = {
+		.platform_data	= &am33xx_cpuidle_pdata,
+	},
+};
+
+static void __init am33xx_cpuidle_init(void)
+{
+	int ret;
+
+	am33xx_cpuidle_pdata.emif_base = am33xx_get_mem_ctlr();
+
+	ret = platform_device_register(&am33xx_cpuidle_device);
+
+	if (ret)
+		pr_warning("AM33XX cpuidle registration failed\n");
+
+}
+
+/* Setup McASP 0 (Multichannel Audio Serial Port) */
+static void mcasp0_init(void)
+{
+	/* Configure McASP */
+	setup_pin_mux(mcasp0_pin_mux);
+	am335x_register_mcasp(&pcm051_snd_data0, 0);
+	return;
+}
+
+
+static void __init pcm051_init(void)
+{
+	am33xx_cpuidle_init();
+	am33xx_mux_init(board_mux);
+	pcm051_mux_init();
+	pcm051_rtc_irq_init();
+	omap_serial_init();
+	clkout1_enable();
+	pcm051_i2c_init();
+	am335x_internal_rtc_init();
+	mcasp0_init();
+	omap_sdrc_init(NULL, NULL);
+	usb_musb_init(&musb_board_data);
+	/* Create an alias for icss clock */
+	if (clk_add_alias("pruss", NULL, "pruss_uart_gclk", NULL))
+		pr_warn("failed to create an alias: pruss_uart_gclk --> pruss\n");
+	/* Create an alias for gfx/sgx clock */
+	if (clk_add_alias("sgx_ck", NULL, "gfx_fclk", NULL))
+		pr_warn("failed to create an alias: gfx_fclk --> sgx_ck\n");
+}
+
+static void __init pcm051_map_io(void)
+{
+	omap2_set_globals_am33xx();
+	omapam33xx_map_common_io();
+}
+
+MACHINE_START(PCM051, "pcm051")
+	/* Maintainer: PHYTEC America */
+	.atag_offset	= 0x100,
+	.map_io		= pcm051_map_io,
+	.init_early	= am33xx_init_early,
+	.init_irq	= ti81xx_init_irq,
+	.handle_irq     = omap3_intc_handle_irq,
+	.timer		= &omap3_am33xx_timer,
+	.init_machine	= pcm051_init,
+MACHINE_END
diff --git a/arch/arm/mach-omap2/board-pfla03.c b/arch/arm/mach-omap2/board-pfla03.c
new file mode 100644
index 0000000..4c46491
--- /dev/null
+++ b/arch/arm/mach-omap2/board-pfla03.c
@@ -0,0 +1,700 @@
+/*
+ * Board support file for Phytec phyFLEX-AM335x Board.
+ *
+ * Copyright (C) 2013 Phytec Embedded Pvt. Ltd.
+ *
+ * Author: Teresa Gámez <t.gamez@phytec.de>
+ *
+ * Based on mach-omap2/board-am335xevm.c
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/mfd/tps65217.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/reboot.h>
+#include <linux/opp.h>
+#include <linux/leds-pca9532.h>
+#include <linux/phy.h>
+#include <linux/ethtool.h>
+#include <linux/micrel_phy.h>
+#include <linux/pwm/pwm.h>
+#include <linux/pwm_backlight.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+#include <video/da8xx-fb.h>
+
+#include <mach/hardware.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/hardware/asp.h>
+
+#include <plat/omap_device.h>
+#include <plat/irqs.h>
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/mmc.h>
+#include <plat/nand.h>
+#include <plat/lcdc.h>
+#include <plat/usb.h>
+
+#include "board-flash.h"
+#include "cpuidle33xx.h"
+#include "mux.h"
+#include "hsmmc.h"
+#include "devices.h"
+
+/* Convert GPIO signal to GPIO pin number */
+#define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
+#include "common.h"
+#include "am33xx_generic.h"
+
+/* module pin mux structure */
+struct pinmux_config {
+	const char *string_name; /* signal name format */
+	int val; /* Options for the mux register value */
+};
+
+/*
+ * @pin_mux - single module pin-mux structure which defines pin-mux
+ *                      details for all its pins.
+ */
+static void setup_pin_mux(struct pinmux_config *pin_mux)
+{
+	int i;
+
+	for (i = 0; pin_mux->string_name != NULL; pin_mux++)
+		omap_mux_init_signal(pin_mux->string_name, pin_mux->val);
+}
+
+/* Module pin mux for mmc0 */
+static struct pinmux_config mmc0_pin_mux[] = {
+	{"mmc0_dat3.mmc0_dat3",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat2.mmc0_dat2",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat1.mmc0_dat1",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat0.mmc0_dat0",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_clk.mmc0_clk",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_cmd.mmc0_cmd",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mcasp0_aclkr.gpio3_18", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_a1.gpio1_17",	OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+static struct omap_board_mux board_mux[] __initdata = {
+	AM33XX_MUX(I2C0_SDA, OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
+			AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT),
+	AM33XX_MUX(I2C0_SCL, OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
+			AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+
+/* Pin mux for nand flash module */
+static struct pinmux_config nand_pin_mux[] = {
+	{"gpmc_ad0.gpmc_ad0",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad1.gpmc_ad1",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad2.gpmc_ad2",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad3.gpmc_ad3",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad4.gpmc_ad4",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad5.gpmc_ad5",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad6.gpmc_ad6",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad7.gpmc_ad7",     OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_wait0.gpmc_wait0", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_wpn.gpmc_wpn",     OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_csn0.gpmc_csn0",   OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_advn_ale.gpmc_advn_ale",  OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_oen_ren.gpmc_oen_ren",    OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_wen.gpmc_wen",     OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{"gpmc_ben0_cle.gpmc_ben0_cle",  OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
+	{NULL, 0},
+};
+
+static struct pinmux_config lcdc_pin_mux[] = {
+	{"lcd_data0.lcd_data0",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data1.lcd_data1",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data2.lcd_data2",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data3.lcd_data3",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data4.lcd_data4",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data5.lcd_data5",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data6.lcd_data6",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data7.lcd_data7",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data8.lcd_data8",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data9.lcd_data9",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data10.lcd_data10",       OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data11.lcd_data11",       OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data12.lcd_data12",       OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data13.lcd_data13",       OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data14.lcd_data14",       OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"lcd_data15.lcd_data15",       OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+							| AM33XX_PULL_DISA},
+	{"gpmc_ad8.lcd_data16",         OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad9.lcd_data17",         OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad10.lcd_data18",        OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad11.lcd_data19",        OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad12.lcd_data20",        OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad13.lcd_data21",        OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad14.lcd_data22",        OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"gpmc_ad15.lcd_data23",        OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
+	{"lcd_vsync.lcd_vsync",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_hsync.lcd_hsync",         OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_pclk.lcd_pclk",           OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"mcasp0_ahclkx.gpio3_21",	OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+/* Module pin mux for rmii2 */
+static struct pinmux_config rmii2_pin_mux[] = {
+	{"gpmc_a0.rmii2_txen", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
+	{"gpmc_wpn.rmii2_rxerr", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a4.rmii2_txd1", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a5.rmii2_txd0", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
+	{"mii1_col.rmii2_refclk", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a10.rmii2_rxd1", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a11.rmii2_rxd0", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
+	{"gpmc_wait0.rmii2_crs_dv", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"gpmc_a6.gpio1_22", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+/* Module pin mux for rgmii1 */
+static struct pinmux_config rgmii1_pin_mux[] = {
+	{"mii1_txen.rgmii1_tctl", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"mii1_rxdv.rgmii1_rctl", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_txd3.rgmii1_td3", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"mii1_txd2.rgmii1_td2", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"mii1_txd1.rgmii1_td1", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"mii1_txd0.rgmii1_td0", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"mii1_txclk.rgmii1_tclk", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
+	{"mii1_rxclk.rgmii1_rclk", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_rxd3.rgmii1_rd3", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_rxd2.rgmii1_rd2", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_rxd1.rgmii1_rd1", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mii1_rxd0.rgmii1_rd0", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
+	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* Module pin mux for eCAP2 */
+static struct pinmux_config ecap2_pin_mux[] = {
+	{"mcasp0_ahclkr.ecap2_in_pwm2_out",
+		OMAP_MUX_MODE4 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+/* Module pin mux for SPI fash */
+static struct pinmux_config spi0_pin_mux[] = {
+	{"spi0_sclk.spi0_sclk", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL
+							| AM33XX_INPUT_EN},
+	{"spi0_d0.spi0_d0", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL | AM33XX_PULL_UP
+							| AM33XX_INPUT_EN},
+	{"spi0_d1.spi0_d1", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL
+							| AM33XX_INPUT_EN},
+	{"spi0_cs0.spi0_cs0", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL | AM33XX_PULL_UP
+							| AM33XX_INPUT_EN},
+	{NULL, 0},
+};
+
+/* UART1 pin mux */
+static struct pinmux_config uart1_pin_mux[] = {
+	{"uart1_txd.uart1_txd", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL},
+	{"uart1_rxd.uart1_rxd", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"uart1_ctsn.uart1_ctsn", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"uart1_rtsn.uart1_rtsn", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT},
+	{NULL, 0},
+};
+
+/* pinmux for usb0 drvvbus */
+static struct pinmux_config usb0_pin_mux[] = {
+	{"usb0_drvvbus.usb0_drvvbus",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"gpmc_csn1.gpio1_30",	OMAP_MUX_MODE7 | AM33XX_PULL_ENBL |
+					AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+/* pinmux for usb1 drvvbus */
+static struct pinmux_config usb1_pin_mux[] = {
+	{"usb1_drvvbus.usb1_drvvbus",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"gpmc_csn2.gpio1_31",	OMAP_MUX_MODE7 | AM33XX_PULL_ENBL |
+					AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+static struct omap2_hsmmc_info am335x_mmc[] __initdata = {
+	{
+		.mmc		= 1,
+		.caps		= MMC_CAP_4_BIT_DATA,
+		.gpio_cd	= GPIO_TO_PIN(1, 17),
+		.gpio_wp	= GPIO_TO_PIN(3, 18),
+		.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34, /* 3V3 */
+	},
+	{}	/* Terminator */
+};
+
+static struct gpmc_timings am335x_nand_timings = {
+
+/* granularity of 10 is sufficient because of calculations */
+	.sync_clk = 0,
+
+	.cs_on = 0,
+	.cs_rd_off = 30,
+	.cs_wr_off = 30,
+
+	.adv_on = 0,
+	.adv_rd_off = 30,
+	.adv_wr_off = 30,
+
+	.oe_on = 10,
+	.we_off = 20,
+	.oe_off = 30,
+
+	.access = 30,
+	.rd_cycle = 30,
+	.wr_cycle = 30,
+
+	.cs_cycle_delay = 50,
+	.cs_delay_en = 1,
+	.wr_access = 30,
+	.wr_data_mux_bus = 0,
+};
+
+static struct regulator_init_data am335x_dummy = {
+	.constraints.always_on  = true,
+};
+
+static struct regulator_consumer_supply am335x_vdd1_supply[] = {
+	REGULATOR_SUPPLY("vdd_mpu", NULL),
+};
+
+static struct regulator_init_data am335x_vdd1 = {
+	.constraints = {
+		.min_uV                 = 600000,
+		.max_uV                 = 1500000,
+		.valid_modes_mask       = REGULATOR_MODE_NORMAL,
+		.valid_ops_mask         = REGULATOR_CHANGE_VOLTAGE,
+		.always_on              = 1,
+	},
+	.num_consumer_supplies  = ARRAY_SIZE(am335x_vdd1_supply),
+	.consumer_supplies      = am335x_vdd1_supply,
+};
+
+struct tps65910_board am335x_tps65910_info = {
+	.tps65910_pmic_init_data[TPS65910_REG_VRTC]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VIO]      = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD1]     = &am335x_vdd1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD2]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD3]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG1]    = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG2]    = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VPLL]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDAC]     = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX1]    = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX2]    = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX33]   = &am335x_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VMMC]     = &am335x_dummy,
+	.irq						= -EINVAL,
+};
+
+static struct resource am33xx_cpuidle_resources[] = {
+	{
+		.start		= AM33XX_EMIF0_BASE,
+		.end		= AM33XX_EMIF0_BASE + SZ_32K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+static const struct display_panel disp_panel = {
+	VGA,
+	32,
+	32,
+	COLOR_ACTIVE,
+};
+
+static struct lcd_ctrl_config lcd_cfg = {
+	&disp_panel,
+	.ac_bias                = 40,
+	.ac_bias_intrpt         = 0,
+	.dma_burst_sz           = 16,
+	.bpp                    = 32,
+	.fdd                    = 0x80,
+	.tft_alt_mode           = 0,
+	.stn_565_mode           = 0,
+	.mono_8bit_mode         = 0,
+	.invert_line_clock      = 1,
+	.invert_frm_clock       = 1,
+	.sync_edge              = 0,
+	.sync_ctrl              = 1,
+	.raster_order           = 0,
+};
+
+static struct da8xx_lcdc_platform_data lcdc_pdata[] = {
+	{
+		.manu_name              = "PrimeView",
+		.controller_data        = &lcd_cfg,
+		.type                   = "PV_PM070WL4",
+	}, {
+		.manu_name              = "PrimeView",
+		.controller_data        = &lcd_cfg,
+		.type                   = "PV_PD035VL1",
+	}, {
+		.manu_name              = "PrimeView",
+		.controller_data        = &lcd_cfg,
+		.type                   = "PV_PD050VL1",
+	}, {
+		.manu_name              = "PrimeView",
+		.controller_data        = &lcd_cfg,
+		.type                   = "PV_PD104SLF",
+	}
+};
+
+static struct da8xx_lcdc_selection_platform_data lcdc_selection_pdata = {
+	.entries_ptr = lcdc_pdata,
+	.entries_cnt = ARRAY_SIZE(lcdc_pdata)
+};
+
+/* LCD backlight platform Data */
+#define AM335X_BACKLIGHT_MAX_BRIGHTNESS        100
+#define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    100
+#define AM335X_PWM_PERIOD_NANO_SECONDS         100000
+
+#define PWM_DEVICE_ID   "ecap.2"
+
+static struct platform_pwm_backlight_data am335x_backlight_data = {
+	.pwm_id         = PWM_DEVICE_ID,
+	.ch             = -1,
+	.max_brightness = AM335X_BACKLIGHT_MAX_BRIGHTNESS,
+	.dft_brightness = AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS,
+	.pwm_period_ns  = AM335X_PWM_PERIOD_NANO_SECONDS,
+};
+
+/* Setup pwm-backlight */
+static struct platform_device am335x_backlight = {
+	.name           = "pwm-backlight",
+	.id             = -1,
+	.dev            = {
+		.platform_data  = &am335x_backlight_data,
+	}
+};
+
+static struct pwmss_platform_data pwm_pdata = {
+	.version = PWM_VERSION_1
+};
+
+static int backlight_enable;
+
+static void enable_ecap2(void)
+{
+	backlight_enable = 1;
+	setup_pin_mux(ecap2_pin_mux);
+}
+
+static struct omap_musb_board_data pfla03_musb_board_data = {
+	.interface_type = MUSB_INTERFACE_ULPI,
+	/*
+	* mode[0:3] = USB0PORT's mode
+	* mode[4:7] = USB1PORT's mode
+	* PFLA03 has USB0 in Micro OTG mode and USB1 in host mode.
+	*/
+	.mode		= (MUSB_HOST << 4) | MUSB_OTG,
+	.power		= 500,
+	.instances	= 1,
+};
+
+static const struct flash_platform_data am335x_spi_flash = {
+	.type      = "s25fl064k",
+	.name      = "spi_flash",
+};
+
+/*
+ * SPI Flash works at 80Mhz however SPI Controller works at 48MHz.
+ * So setup Max speed to be less than that of Controller speed
+ */
+static struct spi_board_info am335x_spi0_slave_info[] = {
+	{
+		.modalias      = "m25p80",
+		.platform_data = &am335x_spi_flash,
+		.irq           = -1,
+		.max_speed_hz  = 24000000,
+		.bus_num       = 1,
+		.chip_select   = 0,
+	},
+};
+
+/* AM33XX devices support DDR2 power down */
+static struct am33xx_cpuidle_config am33xx_cpuidle_pdata = {
+	.ddr2_pdown	= 1,
+};
+
+static struct platform_device am33xx_cpuidle_device = {
+	.name			= "cpuidle-am33xx",
+	.num_resources		= ARRAY_SIZE(am33xx_cpuidle_resources),
+	.resource		= am33xx_cpuidle_resources,
+	.dev = {
+		.platform_data	= &am33xx_cpuidle_pdata,
+	},
+};
+
+static void mmc0_init(void)
+{
+	setup_pin_mux(mmc0_pin_mux);
+
+	omap2_hsmmc_init(am335x_mmc);
+	return;
+}
+
+static void __init am33xx_cpuidle_init(void)
+{
+	int ret;
+
+	am33xx_cpuidle_pdata.emif_base = am33xx_get_mem_ctlr();
+
+	ret = platform_device_register(&am33xx_cpuidle_device);
+
+	if (ret)
+		pr_warning("AM33XX cpuidle registration failed\n");
+
+}
+
+static void pfla03_nand_init(void)
+{
+	struct omap_nand_platform_data *pdata;
+	struct gpmc_devices_info gpmc_device[2] = {
+		{ NULL, 0 },
+		{ NULL, 0 },
+	};
+
+	setup_pin_mux(nand_pin_mux);
+	pdata = omap_nand_init(NULL, 0, 0, 0, &am335x_nand_timings);
+	if (!pdata)
+		return;
+	pdata->ecc_opt = OMAP_ECC_BCH8_CODE_HW;
+	pdata->elm_used = true;
+	gpmc_device[0].pdata = pdata;
+	gpmc_device[0].flag = GPMC_DEVICE_NAND;
+
+	omap_init_gpmc(gpmc_device, sizeof(gpmc_device));
+	omap_init_elm();
+}
+
+static int __init conf_disp_pll(int rate)
+{
+	struct clk *disp_pll;
+	int ret = -EINVAL;
+
+	disp_pll = clk_get(NULL, "dpll_disp_ck");
+	if (IS_ERR(disp_pll)) {
+		pr_err("Cannot clk_get disp_pll\n");
+		goto out;
+	}
+
+	ret = clk_set_rate(disp_pll, rate);
+	clk_put(disp_pll);
+out:
+	return ret;
+}
+
+#define GPIO_DISPLAY_EN		117
+
+static void pfla03_lcdc_init(void)
+{
+	int status;
+
+	setup_pin_mux(lcdc_pin_mux);
+
+	status = gpio_request(GPIO_DISPLAY_EN, "lcd_en\n");
+	if (status < 0) {
+		pr_err("Failed to request gpio for display enable");
+		return;
+	}
+
+	gpio_direction_output(GPIO_DISPLAY_EN, 0);
+
+	if (conf_disp_pll(300000000)) {
+		pr_info("Failed configure display PLL, not attempting to"
+				"register LCDC\n");
+	return;
+	}
+
+	if (am33xx_register_lcdc(&lcdc_selection_pdata))
+		pr_info("Failed to register LCDC device\n");
+	return;
+}
+
+static void pfla03_eth_init(void)
+{
+	int status;
+
+	status = gpio_request(GPIO_TO_PIN(1, 22), "gpio1_22");
+	if (status < 0)
+		pr_warn("Failed to request gpio for rmii2_crs_dv\n");
+
+	gpio_direction_output(GPIO_TO_PIN(1, 22), 1);
+
+	setup_pin_mux(rgmii1_pin_mux);
+	setup_pin_mux(rmii2_pin_mux);
+	am33xx_cpsw_init(AM33XX_CPSW_MODE_RMII2_RGMII1, "0:02", "0:00");
+	return;
+}
+
+static int __init ecap2_init(void)
+{
+
+	if (backlight_enable) {
+		am33xx_register_ecap(2, &pwm_pdata);
+		platform_device_register(&am335x_backlight);
+	}
+
+	return 0;
+}
+late_initcall(ecap2_init);
+
+static void pfla03_usb_init(void)
+{
+	setup_pin_mux(usb0_pin_mux);
+	setup_pin_mux(usb1_pin_mux);
+	usb_musb_init(&pfla03_musb_board_data);
+	return;
+}
+
+/* setup spi0 */
+static void pfla03_spi0_init(void)
+{
+	setup_pin_mux(spi0_pin_mux);
+	spi_register_board_info(am335x_spi0_slave_info,
+			ARRAY_SIZE(am335x_spi0_slave_info));
+	return;
+}
+
+/* UART1 init */
+static void pfla03_uart1_init(void)
+{
+	setup_pin_mux(uart1_pin_mux);
+	return;
+}
+
+static struct pca9532_platform_data pba_pca9532 = {
+	.leds = {
+		{
+			.name = "board:red:user_led0",
+			.state = PCA9532_OFF,
+			.type = PCA9532_TYPE_LED,
+		}, {
+			.name = "board:yellow:user_led1",
+			.state = PCA9532_OFF,
+			.type = PCA9532_TYPE_LED,
+		}, {
+			.name = "board:yellow:user_led2",
+			.state = PCA9532_OFF,
+			.type = PCA9532_TYPE_LED,
+		}, {
+			.name = "board:green:user_led3",
+			.state = PCA9532_OFF,
+			.type = PCA9532_TYPE_LED,
+		},
+	},
+	.psc = { 1, 1 },
+	.pwm = { 1, 1 },
+};
+
+static struct i2c_board_info __initdata pfla03_i2c0_boardinfo[] = {
+	{
+		I2C_BOARD_INFO("tps65910", TPS65910_I2C_ID1),
+		.platform_data  = &am335x_tps65910_info,
+	},
+	{
+		I2C_BOARD_INFO("24c32", 0x52),
+	},
+	{
+		I2C_BOARD_INFO("pca9533", 0x62),
+		.platform_data = &pba_pca9532,
+	},
+	{
+		I2C_BOARD_INFO("max1037", 0x64),
+	},
+	{
+		I2C_BOARD_INFO("rtc8564", 0x51),
+	},
+};
+
+static void __init pfla03_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 100, pfla03_i2c0_boardinfo,
+				ARRAY_SIZE(pfla03_i2c0_boardinfo));
+}
+
+static void __init pfla03_init(void)
+{
+	am33xx_cpuidle_init();
+	pfla03_uart1_init();
+	omap_serial_init();
+	omap_sdrc_init(NULL, NULL);
+	/* Create an alias for icss clock */
+	if (clk_add_alias("pruss", NULL, "pruss_uart_gclk", NULL))
+		pr_warn("failed to create an alias: pruss_uart_gclk --> pruss\n");
+	/* Create an alias for gfx/sgx clock */
+	if (clk_add_alias("sgx_ck", NULL, "gfx_fclk", NULL))
+		pr_warn("failed to create an alias: gfx_fclk --> sgx_ck\n");
+	am33xx_mux_init(board_mux);
+	enable_ecap2();
+	pfla03_i2c_init();
+	mmc0_init();
+	pfla03_nand_init();
+	pfla03_lcdc_init();
+	pfla03_eth_init();
+	pfla03_usb_init();
+	pfla03_spi0_init();
+}
+
+static void __init pfla03_map_io(void)
+{
+	omap2_set_globals_am33xx();
+	omapam33xx_map_common_io();
+}
+
+MACHINE_START(PFLA03, "pfla03")
+	/* Maintainer: PHYTEC */
+	.atag_offset	= 0x100,
+	.map_io		= pfla03_map_io,
+	.init_early	= am33xx_init_early,
+	.init_irq	= ti81xx_init_irq,
+	.handle_irq	= omap3_intc_handle_irq,
+	.timer		= &omap3_am33xx_timer,
+	.init_machine	= pfla03_init,
+MACHINE_END
diff --git a/arch/arm/mach-omap2/clock33xx_data.c b/arch/arm/mach-omap2/clock33xx_data.c
index bdbfa78..032f6bf 100644
--- a/arch/arm/mach-omap2/clock33xx_data.c
+++ b/arch/arm/mach-omap2/clock33xx_data.c
@@ -148,7 +148,7 @@ static const struct clksel sys_clkin_sel[] = {
 /* sys_clk_in */
 static struct clk sys_clkin_ck = {
 	.name		= "sys_clkin_ck",
-	.parent		= &virt_24m_ck,
+	.parent		= &virt_25m_ck,
 	.init		= &omap2_init_clksel_parent,
 	.clksel_reg	= AM33XX_CTRL_REGADDR(0x40),	/* CONTROL_STATUS */
 	.clksel_mask	= (0x3 << 22),
@@ -644,6 +644,14 @@ static struct clk clk_24mhz = {
 	.recalc		= &omap_fixed_divisor_recalc,
 };
 
+static struct clk clk_25mhz = {
+	.name		= "clk_25mhz",
+	.parent		= &per_192mhz_clk,
+	.fixed_div	= 8,
+	.ops		= &clkops_null,
+	.recalc		= &omap_fixed_divisor_recalc,
+};
+
 static struct clk l4_cefuse_gclk = {
 	.name		= "l4_cefsue_gclk",
 	.parent		= &core_100mhz_ck,
@@ -709,9 +717,9 @@ static struct clk aes0_fck = {
  */
 static struct clk clkdiv32k_ick = {
 	.name		= "clkdiv32k_ick",
-	.clkdm_name	= "clk_24mhz_clkdm",
+	.clkdm_name	= "clk_25mhz_clkdm",
 	.rate		= 32768,
-	.parent		= &clk_24mhz,
+	.parent		= &clk_25mhz,
 	.enable_reg	= AM33XX_CM_PER_CLKDIV32K_CLKCTRL,
 	.enable_bit	= AM33XX_MODULEMODE_SWCTRL,
 	.ops		= &clkops_omap2_dflt,
@@ -719,7 +727,7 @@ static struct clk clkdiv32k_ick = {
 
 static struct clk clk_32khz_ck = {
 	.name		= "clk_32khz_ck",
-	.clkdm_name	= "clk_24mhz_clkdm",
+	.clkdm_name	= "clk_25mhz_clkdm",
 	.parent		= &clkdiv32k_ick,
 	.ops		= &clkops_null,
 	.recalc		= &followparent_recalc,
@@ -1914,6 +1922,25 @@ static const struct clksel_rate div8_rates[] = {
 	{ .div = 0 },
 };
 
+static const struct clksel clkout1_div[] = {
+	{ .parent = &sysclkout_pre_ck, .rates = div8_rates },
+	{ .parent = NULL },
+};
+
+static struct clk clkout1_ck = {
+	.name		= "clkout1_ck",
+	.parent		= &sysclkout_pre_ck,
+	.ops		= &clkops_omap2_dflt,
+	.clksel		= clkout1_div,
+	.clksel_reg	= AM33XX_CM_CLKOUT_CTRL,
+	.clksel_mask	= AM33XX_CLKOUT2DIV_MASK,
+	.enable_reg	= AM33XX_CM_CLKOUT_CTRL,
+	.enable_bit	= AM33XX_CLKOUT2EN_SHIFT,
+	.recalc		= &omap2_clksel_recalc,
+	.round_rate	= &omap2_clksel_round_rate,
+	.set_rate	= &omap2_clksel_set_rate,
+};
+
 static const struct clksel clkout2_div[] = {
 	{ .parent = &sysclkout_pre_ck, .rates = div8_rates },
 	{ .parent = NULL },
@@ -2167,6 +2194,7 @@ static struct omap_clk am33xx_clks[] = {
 	CLK(NULL,	"l4ls_gclk",		&l4ls_gclk,		CK_AM33XX),
 	CLK(NULL,	"debug_clka_gclk",	&debug_clka_gclk,	CK_AM33XX),
 	CLK(NULL,	"clk_24mhz",		&clk_24mhz,		CK_AM33XX),
+	CLK(NULL,	"clk_25mhz",		&clk_25mhz,	CK_AM33XX),
 	CLK(NULL,	"sysclk_div_ck",	&sysclk_div_ck,		CK_AM33XX),
 	CLK(NULL,	"cpsw_250mhz_clk",	&cpsw_250mhz_clk,	CK_AM33XX),
 	CLK(NULL,	"cpsw_125mhz_gclk",	&cpsw_125mhz_gclk,	CK_AM33XX),
@@ -2184,6 +2212,7 @@ static struct omap_clk am33xx_clks[] = {
 	CLK(NULL,	"gfx_fclk",		&gfx_fclk,		CK_AM33XX),
 	CLK(NULL,	"gfx_ick",		&gfx_ick,		CK_AM33XX),
 	CLK(NULL,	"sysclkout_pre_ck",	&sysclkout_pre_ck,	CK_AM33XX),
+	CLK(NULL,	"clkout1_ck",		&clkout1_ck,	CK_AM33XX),
 	CLK(NULL,	"clkout2_ck",		&clkout2_ck,		CK_AM33XX),
 	CLK(NULL,	"gpt0_ick",		&timer0_ick,		CK_AM33XX),
 	CLK(NULL,	"gpt1_ick",		&timer1_ick,		CK_AM33XX),
diff --git a/arch/arm/mach-omap2/clockdomains33xx_data.c b/arch/arm/mach-omap2/clockdomains33xx_data.c
index a4734e9..3dc2e01 100644
--- a/arch/arm/mach-omap2/clockdomains33xx_data.c
+++ b/arch/arm/mach-omap2/clockdomains33xx_data.c
@@ -122,6 +122,16 @@ static struct clockdomain clk_24mhz_am33xx_clkdm = {
 	.flags		= (CLKDM_CAN_SWSUP | CLKDM_NO_AUTODEPS),
 };
 
+static struct clockdomain clk_25mhz_am33xx_clkdm = {
+	.name		= "clk_25mhz_clkdm",
+	.pwrdm		= { .name = "per_pwrdm" },
+	.cm_inst	= AM33XX_CM_PER_MOD,
+	.prcm_partition	= AM33XX_PRM_PARTITION,
+	.clkdm_offs	= AM33XX_CM_PER_CLK_24MHZ_CLKSTCTRL_OFFSET,
+	.clktrctrl_mask	= AM33XX_CLKTRCTRL_MASK,
+	.flags		= (CLKDM_CAN_SWSUP | CLKDM_NO_AUTODEPS),
+};
+
 static struct clockdomain l4_wkup_am33xx_clkdm = {
 	.name		= "l4_wkup_clkdm",
 	.pwrdm		= { .name = "wkup_pwrdm" },
@@ -213,6 +223,7 @@ static struct clockdomain *clockdomains_am33xx[] __initdata = {
 	&cpsw_125mhz_am33xx_clkdm,
 	&lcdc_am33xx_clkdm,
 	&clk_24mhz_am33xx_clkdm,
+	&clk_25mhz_am33xx_clkdm,
 	&l4_wkup_am33xx_clkdm,
 	&l3_aon_am33xx_clkdm,
 	&l4_wkup_aon_am33xx_clkdm,
diff --git a/arch/arm/mach-omap2/control.h b/arch/arm/mach-omap2/control.h
index 9b75204..2d1b680 100644
--- a/arch/arm/mach-omap2/control.h
+++ b/arch/arm/mach-omap2/control.h
@@ -371,11 +371,25 @@
  */
 #define AM33XX_CONTROL_GMII_SEL_OFFSET	0x650
 #define AM33XX_RGMII_DISABLE_INT_DLY	(BIT(4) | BIT(5))
+#define AM33XX_RMII1_SRC_CLK_PIN	BIT(6)
+#define AM33XX_RMII2_SRC_CLK_PIN	BIT(7)
+
 #define AM33XX_MII_MODE_EN		0x0
-#define AM33XX_RMII_MODE_EN		((1 << 0) | (1 << 2))
+
+#define AM33XX_RMII_MODE_EN		((1 << 0) | (1 << 2) | \
+					AM33XX_RMII1_SRC_CLK_PIN)
+
 #define AM33XX_RGMII_MODE_EN		((0x2 << 0) | (0x2 << 2) | \
 					(AM33XX_RGMII_DISABLE_INT_DLY))
 
+#define AM33XX_RMII1_RGMII2_MODE_EN	((0x1 << 0) | (0x2 << 2) | \
+					AM33XX_RMII1_SRC_CLK_PIN | \
+					AM33XX_RGMII_DISABLE_INT_DLY)
+
+#define AM33XX_RMII2_RGMII1_MODE_EN	((0x2 << 0) |  (0x1 << 2) | \
+					AM33XX_RMII2_SRC_CLK_PIN | \
+					AM33XX_RGMII_DISABLE_INT_DLY)
+
 /*
  * CONTROL AM33XX PWMSS_CTRL register to enable time base clock Enable
  */
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 85dafbe..0ef4cc5 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -151,7 +151,8 @@ static struct platform_device omap2cam_device = {
 };
 #endif
 
-int __init am33xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata)
+int __init am33xx_register_lcdc
+	(struct da8xx_lcdc_selection_platform_data *pdata)
 {
 	int id = 0;
 	struct platform_device *pdev;
@@ -166,7 +167,9 @@ int __init am33xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata)
 	}
 
 	pdev = omap_device_build(dev_name, id, oh, pdata,
-			sizeof(struct da8xx_lcdc_platform_data), NULL, 0, 0);
+			sizeof(struct da8xx_lcdc_selection_platform_data),
+			NULL, 0, 0);
+
 	if (IS_ERR(pdev)) {
 		WARN(1, "Can't build omap_device for %s:%s.\n",
 			dev_name, oh->name);
@@ -198,7 +201,9 @@ int __init am33xx_register_mfd_tscadc(struct mfd_tscadc_board *pdata)
 }
 
 #if defined(CONFIG_SND_AM335X_SOC_EVM) || \
-				defined(CONFIG_SND_AM335X_SOC_EVM_MODULE)
+	defined(CONFIG_SND_AM335X_SOC_EVM_MODULE) || \
+	defined(CONFIG_SND_PCM051_SOC_BOARD) || \
+	defined(CONFIG_SND_PCM051_SOC_BOARD_MODULE)
 int __init am335x_register_mcasp(struct snd_platform_data *pdata, int ctrl_nr)
 {
 	int l;
@@ -1204,10 +1209,11 @@ static struct cpsw_slave_data am33xx_cpsw_slaves[] = {
 		.phy_id		= "0:00",
 		.dual_emac_reserved_vlan = CPSW_PORT_VLAN_SLAVE_0,
 	},
+
 	{
 		.slave_reg_ofs  = 0x300,
 		.sliver_reg_ofs = 0xdc0,
-		.phy_id		= "0:01",
+		.phy_id		= "0:02",
 		.dual_emac_reserved_vlan = CPSW_PORT_VLAN_SLAVE_1,
 	},
 };
@@ -1233,6 +1239,7 @@ static struct cpsw_platform_data am33xx_cpsw_pdata = {
 	.host_port_num		= 0,
 	.no_bd_ram		= false,
 	.version		= CPSW_VERSION_2,
+	.default_vlan		= CPSW_PORT_VLAN_SLAVE_1,
 };
 
 static struct mdio_platform_data am33xx_cpsw_mdiopdata = {
@@ -1284,11 +1291,11 @@ int am33xx_cpsw_init(enum am33xx_cpsw_mac_mode mode, unsigned char *phy_id0,
 	am33xx_cpsw_slaves[0].mac_addr[5] = (mac_lo & 0xFF00) >> 8;
 
 	/* Read MACID0 from eeprom if eFuse MACID is invalid */
-	if (!is_valid_ether_addr(am33xx_cpsw_slaves[0].mac_addr)) {
+/*	if (!is_valid_ether_addr(am33xx_cpsw_slaves[0].mac_addr)) {
 		for (i = 0; i < ETH_ALEN; i++)
 			am33xx_cpsw_slaves[0].mac_addr[i] = am33xx_macid0[i];
 	}
-
+*/
 	mac_lo = omap_ctrl_readl(TI81XX_CONTROL_MAC_ID1_LO);
 	mac_hi = omap_ctrl_readl(TI81XX_CONTROL_MAC_ID1_HI);
 	am33xx_cpsw_slaves[1].mac_addr[0] = mac_hi & 0xFF;
@@ -1299,10 +1306,11 @@ int am33xx_cpsw_init(enum am33xx_cpsw_mac_mode mode, unsigned char *phy_id0,
 	am33xx_cpsw_slaves[1].mac_addr[5] = (mac_lo & 0xFF00) >> 8;
 
 	/* Read MACID1 from eeprom if eFuse MACID is invalid */
-	if (!is_valid_ether_addr(am33xx_cpsw_slaves[1].mac_addr)) {
+/*	if (!is_valid_ether_addr(am33xx_cpsw_slaves[1].mac_addr)) {
 		for (i = 0; i < ETH_ALEN; i++)
 			am33xx_cpsw_slaves[1].mac_addr[i] = am33xx_macid1[i];
 	}
+*/
 
 	switch (mode) {
 	case AM33XX_CPSW_MODE_MII:
@@ -1316,6 +1324,12 @@ int am33xx_cpsw_init(enum am33xx_cpsw_mac_mode mode, unsigned char *phy_id0,
 		am33xx_cpsw_slaves[0].phy_if = PHY_INTERFACE_MODE_RGMII;
 		am33xx_cpsw_slaves[1].phy_if = PHY_INTERFACE_MODE_RGMII;
 		break;
+	case AM33XX_CPSW_MODE_RMII1_RGMII2:
+		gmii_sel = AM33XX_RMII1_RGMII2_MODE_EN;
+		break;
+	case AM33XX_CPSW_MODE_RMII2_RGMII1:
+		gmii_sel = AM33XX_RMII2_RGMII1_MODE_EN;
+		break;
 	default:
 		return -EINVAL;
 	}
diff --git a/arch/arm/mach-omap2/gpmc-nand.c b/arch/arm/mach-omap2/gpmc-nand.c
index 0207a66..7cb6a2c 100644
--- a/arch/arm/mach-omap2/gpmc-nand.c
+++ b/arch/arm/mach-omap2/gpmc-nand.c
@@ -47,7 +47,7 @@ static int omap2_nand_gpmc_retime(struct omap_nand_platform_data *gpmc_nand_data
 	/* Read */
 	t.adv_rd_off = gpmc_round_ns_to_ticks(
 				gpmc_nand_data->gpmc_t->adv_rd_off);
-	t.oe_on  = t.adv_on;
+	t.oe_on  = gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->oe_on);
 	t.access = gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->access);
 	t.oe_off = gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->oe_off);
 	t.cs_rd_off = gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->cs_rd_off);
@@ -56,7 +56,7 @@ static int omap2_nand_gpmc_retime(struct omap_nand_platform_data *gpmc_nand_data
 	/* Write */
 	t.adv_wr_off = gpmc_round_ns_to_ticks(
 				gpmc_nand_data->gpmc_t->adv_wr_off);
-	t.we_on  = t.oe_on;
+	t.we_on  = t.adv_on;
 	if (cpu_is_omap34xx()) {
 	    t.wr_data_mux_bus =	gpmc_round_ns_to_ticks(
 				gpmc_nand_data->gpmc_t->wr_data_mux_bus);
@@ -67,6 +67,11 @@ static int omap2_nand_gpmc_retime(struct omap_nand_platform_data *gpmc_nand_data
 	t.cs_wr_off = gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->cs_wr_off);
 	t.wr_cycle  = gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->wr_cycle);
 
+	/* Cycle to cycle delay */
+	t.cs_delay_en = gpmc_nand_data->gpmc_t->cs_delay_en;
+	t.cs_cycle_delay = \
+		gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->cs_cycle_delay);
+
 	/* Configure GPMC */
 	if (gpmc_nand_data->devsize == NAND_BUSWIDTH_16)
 		gpmc_cs_configure(gpmc_nand_data->cs, GPMC_CONFIG_DEV_SIZE, 1);
diff --git a/arch/arm/mach-omap2/gpmc.c b/arch/arm/mach-omap2/gpmc.c
index b8e02751..6b3aeed 100644
--- a/arch/arm/mach-omap2/gpmc.c
+++ b/arch/arm/mach-omap2/gpmc.c
@@ -69,6 +69,8 @@
 #define ENABLE_PREFETCH		(0x1 << 7)
 #define DMA_MPU_MODE		2
 
+#define CYCLE2CYCLE_DIFF_CS_EN	0x40
+
 /* Structure to save gpmc cs context */
 struct gpmc_cs_config {
 	u32 config1;
@@ -332,6 +334,11 @@ int gpmc_cs_set_timings(int cs, const struct gpmc_timings *t)
 
 	GPMC_SET_ONE(GPMC_CS_CONFIG5, 24, 27, page_burst_access);
 
+	if (t->cs_delay_en != 0) {
+		gpmc_cs_write_reg(cs, GPMC_CS_CONFIG6, CYCLE2CYCLE_DIFF_CS_EN);
+		GPMC_SET_ONE(GPMC_CS_CONFIG6, 8, 11, cs_cycle_delay);
+	}
+
 	if (cpu_is_omap34xx()) {
 		GPMC_SET_ONE(GPMC_CS_CONFIG6, 16, 19, wr_data_mux_bus);
 		GPMC_SET_ONE(GPMC_CS_CONFIG6, 24, 28, wr_access);
diff --git a/arch/arm/mach-omap2/include/mach/board-pcm051.h b/arch/arm/mach-omap2/include/mach/board-pcm051.h
new file mode 100644
index 0000000..acd40c8
--- /dev/null
+++ b/arch/arm/mach-omap2/include/mach/board-pcm051.h
@@ -0,0 +1,49 @@
+/*
+ * Code for supporting PCM051.
+ *
+ * Copyright (C) {2012} PHYTEC America LLC - http://www.phytec.com
+ *
+ * Based on AM335X EVM.
+ *
+ * Copyright (C) {2011} Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _BOARD_AM335X_H
+#define _BOARD_AM335X_H
+
+#define EEPROM_I2C_ADDR		0x52
+
+#define LOW_COST_EVM		0
+#define GEN_PURP_EVM		1
+#define IND_AUT_MTR_EVM		2
+#define IP_PHN_EVM		3
+#define BEAGLE_BONE_OLD		4
+#define BEAGLE_BONE_A3		5
+
+
+/* REVIST : check posibility of PROFILE_(x) syntax usage */
+#define PROFILE_NONE	-1	/* Few EVM doesn't have profiles */
+#define PROFILE_0		(0x1 << 0)
+#define PROFILE_1		(0x1 << 1)
+#define PROFILE_2		(0x1 << 2)
+#define PROFILE_3		(0x1 << 3)
+#define PROFILE_4		(0x1 << 4)
+#define PROFILE_5		(0x1 << 5)
+#define PROFILE_6		(0x1 << 6)
+#define PROFILE_7		(0x1 << 7)
+#define PROFILE_ALL		0xFF
+
+void am33xx_evmid_fillup(unsigned int evmid);
+void am33xx_cpsw_macidfillup(char *eeprommacid0, char *eeprommacid1);
+void am33xx_d_can_init(unsigned int instance);
+
+#endif
diff --git a/arch/arm/mach-omap2/mux.c b/arch/arm/mach-omap2/mux.c
index 8b9254a..a2536a4 100644
--- a/arch/arm/mach-omap2/mux.c
+++ b/arch/arm/mach-omap2/mux.c
@@ -865,12 +865,16 @@ static int __init omap_mux_late_init(void)
 		}
 	}
 
-	ret = request_irq(omap_prcm_event_to_irq("io"),
-		omap_hwmod_mux_handle_irq, IRQF_SHARED | IRQF_NO_SUSPEND,
-			"hwmod_io", omap_mux_late_init);
-
-	if (ret)
-		pr_warning("mux: Failed to setup hwmod io irq %d\n", ret);
+	if (!cpu_is_am33xx()) {
+		ret = request_irq(omap_prcm_event_to_irq("io"),
+					omap_hwmod_mux_handle_irq,
+					IRQF_SHARED | IRQF_NO_SUSPEND,
+					"hwmod_io", omap_mux_late_init);
+
+		if (ret)
+			pr_warning("mux: Failed to setup hwmod io irq %d\n",
+									ret);
+	}
 
 	omap_mux_dbg_init();
 
diff --git a/arch/arm/mach-omap2/mux33xx.c b/arch/arm/mach-omap2/mux33xx.c
index 2db09b2..e10e7b1 100644
--- a/arch/arm/mach-omap2/mux33xx.c
+++ b/arch/arm/mach-omap2/mux33xx.c
@@ -253,10 +253,10 @@ static struct omap_mux am33xx_muxmodes[] = {
 		"mii1_rxdv", NULL, "rgmii1_rctl", NULL,
 		"mcasp1_aclx", "mmc2_dat0", "mcasp0_aclkr", "gpio3_4"),
 	_AM33XX_MUXENTRY(MII1_TXD3, 0,
-		"mii1_txd3", NULL, "rgmii1_td3", NULL,
+		"mii1_txd3", "dcan0_tx_mux0", "rgmii1_td3", NULL,
 		"mcasp1_fsx", "mmc2_dat1", "mcasp0_fsr", "gpio0_16"),
 	_AM33XX_MUXENTRY(MII1_TXD2, 0,
-		"mii1_txd2", NULL, "rgmii1_td2", NULL,
+		"mii1_txd2", "dcan0_rx_mux0", "rgmii1_td2", NULL,
 		"mcasp1_axr0", "mmc2_dat2", "mcasp0_ahclkx", "gpio0_17"),
 	_AM33XX_MUXENTRY(MII1_TXD1, 0,
 		"mii1_txd1", "rmii1_txd1", "rgmii1_td1", "mcasp1_fsr",
@@ -265,16 +265,16 @@ static struct omap_mux am33xx_muxmodes[] = {
 		"mii1_txd0", "rmii1_txd0", "rgmii1_td0", "mcasp1_axr2",
 		"mcasp1_aclkr", NULL, "mmc1_clk", "gpio0_28"),
 	_AM33XX_MUXENTRY(MII1_TXCLK, 0,
-		"mii1_txclk", NULL, "rgmii1_tclk", "mmc0_dat7",
+		"mii1_txclk", "uart2_rxd_mux0", "rgmii1_tclk", "mmc0_dat7",
 		"mmc1_dat0", NULL, "mcasp0_aclkx", "gpio3_9"),
 	_AM33XX_MUXENTRY(MII1_RXCLK, 0,
-		"mii1_rxclk", NULL, "rgmii1_rclk", "mmc0_dat6",
+		"mii1_rxclk", "uart2_txd_mux0", "rgmii1_rclk", "mmc0_dat6",
 		"mmc1_dat1", NULL, "mcasp0_fsx", "gpio3_10"),
 	_AM33XX_MUXENTRY(MII1_RXD3, 0,
-		"mii1_rxd3", NULL, "rgmii1_rd3", "mmc0_dat5",
+		"mii1_rxd3", "uart3_rxd_mux0", "rgmii1_rd3", "mmc0_dat5",
 		"mmc1_dat2", NULL, "mcasp0_axr0", "gpio2_18"),
 	_AM33XX_MUXENTRY(MII1_RXD2, 0,
-		"mii1_rxd2", NULL, "rgmii1_rd2", "mmc0_dat4",
+		"mii1_rxd2", "uart3_txd_mux0", "rgmii1_rd2", "mmc0_dat4",
 		"mmc1_dat3", NULL, "mcasp0_axr1", "gpio2_19"),
 	_AM33XX_MUXENTRY(MII1_RXD1, 0,
 		"mii1_rxd1", "rmii1_rxd1", "rgmii1_rd1", "mcasp1_axr3",
@@ -328,10 +328,10 @@ static struct omap_mux am33xx_muxmodes[] = {
 		"uart1_rtsn", NULL, NULL, "i2c2_scl",
 		"spi1_cs1", NULL, NULL, "gpio0_13"),
 	_AM33XX_MUXENTRY(UART1_RXD, 0,
-		"uart1_rxd", "mmc1_sdwp", NULL, "i2c1_sda",
+		"uart1_rxd", "mmc1_sdwp", "dcan1_tx_mux2", "i2c1_sda",
 		NULL, "pr1_uart0_rxd_mux1", NULL, "gpio0_14"),
 	_AM33XX_MUXENTRY(UART1_TXD, 0,
-		"uart1_txd", "mmc2_sdwp", NULL, "i2c1_scl",
+		"uart1_txd", "mmc2_sdwp", "dcan1_rx_mux2", "i2c1_scl",
 		NULL, "pr1_uart0_txd_mux1", NULL, "gpio0_15"),
 	_AM33XX_MUXENTRY(I2C0_SDA, 0,
 		"i2c0_sda", NULL, NULL, NULL,
@@ -918,6 +918,8 @@ void am33xx_setup_pinmux_on_suspend(void)
 	}
 }
 
+#ifdef CONFIG_SUSPEND
+
 static u32 am33xx_lp_padconf_complete[MAX_IO_PADCONF];
 
 void am335x_save_padconf(void)
@@ -955,6 +957,8 @@ void am335x_restore_padconf(void)
 	}
 }
 
+#endif
+
 /*
  * Dummy GPIO interrupt Handler
  */
diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
index baf2d01..e6c21d0 100644
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -476,7 +476,7 @@ static struct omap_hwmod_class am33xx_clkdiv32k_hwmod_class = {
 static struct omap_hwmod am33xx_clkdiv32k_hwmod = {
 	.name		= "clkdiv32k",
 	.class		= &am33xx_clkdiv32k_hwmod_class,
-	.clkdm_name	= "clk_24mhz_clkdm",
+	.clkdm_name	= "clk_25mhz_clkdm",
 	.main_clk	= "clkdiv32k_ick",
 	.prcm		= {
 		.omap4	= {
@@ -1216,7 +1216,7 @@ static struct omap_hwmod am33xx_gpio1_hwmod = {
 	.clkdm_name	= "l4ls_clkdm",
 	.mpu_irqs	= am33xx_gpio1_irqs,
 	.main_clk	= "gpio1_ick",
-	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET | HWMOD_INIT_NO_RESET,
 	.prcm		= {
 		.omap4	= {
 			.clkctrl_offs	= AM33XX_CM_PER_GPIO1_CLKCTRL_OFFSET,
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index e0ffe73..d960bea 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -632,7 +632,11 @@ static int __init am33xx_pm_init(void)
 
 
 	/* Get Board Id */
+#ifdef CONFIG_MACH_AM335XEVM
 	evm_id = am335x_evm_get_id();
+#else
+	evm_id = -EINVAL;
+#endif
 	if (evm_id != -EINVAL)
 		suspend_cfg_param_list[EVM_ID] = evm_id;
 	else
diff --git a/arch/arm/plat-omap/include/plat/am33xx.h b/arch/arm/plat-omap/include/plat/am33xx.h
index 5475b5c..3255e4d 100644
--- a/arch/arm/plat-omap/include/plat/am33xx.h
+++ b/arch/arm/plat-omap/include/plat/am33xx.h
@@ -89,6 +89,8 @@ enum am33xx_cpsw_mac_mode {
 	AM33XX_CPSW_MODE_MII,
 	AM33XX_CPSW_MODE_RMII,
 	AM33XX_CPSW_MODE_RGMII,
+	AM33XX_CPSW_MODE_RMII1_RGMII2,
+	AM33XX_CPSW_MODE_RMII2_RGMII1,
 };
 int am33xx_cpsw_init(enum am33xx_cpsw_mac_mode mode, unsigned char *phy_id0,
 		     unsigned char *phy_id1);
diff --git a/arch/arm/plat-omap/include/plat/gpmc.h b/arch/arm/plat-omap/include/plat/gpmc.h
index 2b81fc6..a3bff75 100644
--- a/arch/arm/plat-omap/include/plat/gpmc.h
+++ b/arch/arm/plat-omap/include/plat/gpmc.h
@@ -128,7 +128,9 @@ struct gpmc_timings {
 	u16 rd_cycle;		/* Total read cycle time */
 	u16 wr_cycle;		/* Total write cycle time */
 
-	/* The following are only on OMAP3430 */
+	/* The following are only on OMAP3430 and AM335x */
+	u16 cs_cycle_delay;
+	u16 cs_delay_en;
 	u16 wr_access;		/* WRACCESSTIME */
 	u16 wr_data_mux_bus;	/* WRDATAONADMUXBUS */
 };
diff --git a/arch/arm/plat-omap/include/plat/lcdc.h b/arch/arm/plat-omap/include/plat/lcdc.h
index f8bcdec..f52e176 100644
--- a/arch/arm/plat-omap/include/plat/lcdc.h
+++ b/arch/arm/plat-omap/include/plat/lcdc.h
@@ -17,5 +17,5 @@
 #define __OMAP2_LCDC_H
 
 struct platform_device *am33xx_register_lcdc(
-		struct da8xx_lcdc_platform_data *pdata);
+		struct da8xx_lcdc_selection_platform_data *pdata);
 #endif
diff --git a/arch/arm/plat-omap/include/plat/uncompress.h b/arch/arm/plat-omap/include/plat/uncompress.h
index 8686776..c64f322 100644
--- a/arch/arm/plat-omap/include/plat/uncompress.h
+++ b/arch/arm/plat-omap/include/plat/uncompress.h
@@ -190,6 +190,7 @@ static inline void __arch_decomp_setup(unsigned long arch_id)
 
 		/* AM33XX base boards using UART1 */
 		DEBUG_LL_AM33XX(1, am335xevm);
+		DEBUG_LL_AM33XX(1, pcm051);
 
 		/* AM33XX IA boards using UART4 */
 		DEBUG_LL_AM33XX(4, am335xiaevm);
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 217ea76..54b3506 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1128,3 +1128,6 @@ smdk4212		MACH_SMDK4212		SMDK4212		3638
 smdk4412		MACH_SMDK4412		SMDK4412		3765
 am335xevm		MACH_AM335XEVM		AM335XEVM		3589
 am335xiaevm		MACH_AM335XIAEVM	AM335XIAEVM		3684
+pcm051			MACH_PCM051		PCM051			4144
+pcaaxs1			MACH_PCAAXS1		PCAAXS1			4526
+pfla03			MACH_PFLA03		PFLA03			4575
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index c7d3354..49308eb 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -363,6 +363,19 @@ config TOUCHSCREEN_PENMOUNT
 	  To compile this driver as a module, choose M here: the
 	  module will be called penmount.
 
+config TOUCHSCREEN_EDT_FT5X06
+	tristate "EDT FocalTech FT5x06 I2C Touchscreen support"
+	depends on I2C
+	help
+	  Say Y here if you have an EDT "Polytouch" touchscreen based
+	  on the FocalTech FT5x06 family of controllers connected to
+	  your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called edt-ft5x06.
+
 config TOUCHSCREEN_MIGOR
 	tristate "Renesas MIGO-R touchscreen"
 	depends on SH_MIGOR && I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 24e8034..6342335 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_TOUCHSCREEN_BU21013)       += bu21013_ts.o
 obj-$(CONFIG_TOUCHSCREEN_CY8CTMG110)	+= cy8ctmg110_ts.o
 obj-$(CONFIG_TOUCHSCREEN_DA9034)	+= da9034-ts.o
 obj-$(CONFIG_TOUCHSCREEN_DYNAPRO)	+= dynapro.o
+obj-$(CONFIG_TOUCHSCREEN_EDT_FT5X06)	+= edt-ft5x06.o
 obj-$(CONFIG_TOUCHSCREEN_HAMPSHIRE)	+= hampshire.o
 obj-$(CONFIG_TOUCHSCREEN_GUNZE)		+= gunze.o
 obj-$(CONFIG_TOUCHSCREEN_EETI)		+= eeti_ts.o
diff --git a/drivers/input/touchscreen/edt-ft5x06.c b/drivers/input/touchscreen/edt-ft5x06.c
new file mode 100644
index 0000000..99d8ac9
--- /dev/null
+++ b/drivers/input/touchscreen/edt-ft5x06.c
@@ -0,0 +1,924 @@
+/*
+ * Copyright (C) 2012 Simon Budig, <simon.budig@kernelconcepts.de>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This is a driver for the EDT "Polytouch" family of touch controllers
+ * based on the FocalTech FT5x06 line of chips.
+ *
+ * Development of this driver has been sponsored by Glyn:
+ *    http://www.glyn.com/Products/Displays
+ */
+
+#include <linux/module.h>
+#include <linux/ratelimit.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/input/mt.h>
+#include <linux/input/edt-ft5x06.h>
+
+#define MAX_SUPPORT_POINTS		5
+
+#define WORK_REGISTER_THRESHOLD		0x00
+#define WORK_REGISTER_REPORT_RATE	0x08
+#define WORK_REGISTER_GAIN		0x30
+#define WORK_REGISTER_OFFSET		0x31
+#define WORK_REGISTER_NUM_X		0x33
+#define WORK_REGISTER_NUM_Y		0x34
+
+#define WORK_REGISTER_OPMODE		0x3c
+#define FACTORY_REGISTER_OPMODE		0x01
+
+#define TOUCH_EVENT_DOWN		0x00
+#define TOUCH_EVENT_UP			0x01
+#define TOUCH_EVENT_ON			0x02
+#define TOUCH_EVENT_RESERVED		0x03
+
+#define EDT_NAME_LEN			23
+#define EDT_SWITCH_MODE_RETRIES		10
+#define EDT_SWITCH_MODE_DELAY		5 /* msec */
+#define EDT_RAW_DATA_RETRIES		100
+#define EDT_RAW_DATA_DELAY		1 /* msec */
+
+struct edt_ft5x06_ts_data {
+	struct i2c_client *client;
+	struct input_dev *input;
+	u16 num_x;
+	u16 num_y;
+
+#if defined(CONFIG_DEBUG_FS)
+	struct dentry *debug_dir;
+	u8 *raw_buffer;
+	size_t raw_bufsize;
+#endif
+
+	struct mutex mutex;
+	bool factory_mode;
+	int threshold;
+	int gain;
+	int offset;
+	int report_rate;
+
+	char name[EDT_NAME_LEN];
+};
+
+#ifndef dev_err_ratelimited
+#define dev_level_ratelimited(dev_level, dev, fmt, ...)			\
+do {									\
+	static DEFINE_RATELIMIT_STATE(_rs,				\
+				      DEFAULT_RATELIMIT_INTERVAL,       \
+				      DEFAULT_RATELIMIT_BURST);		\
+	if (__ratelimit(&_rs))						\
+		dev_level(dev, fmt, ##__VA_ARGS__);			\
+} while (0)
+
+#define dev_err_ratelimited(dev, fmt, ...)				\
+	dev_level_ratelimited(dev_err, dev, fmt, ##__VA_ARGS__)
+#endif
+
+
+static int edt_ft5x06_ts_readwrite(struct i2c_client *client,
+				   u16 wr_len, u8 *wr_buf,
+				   u16 rd_len, u8 *rd_buf)
+{
+	struct i2c_msg wrmsg[2];
+	int i = 0;
+	int ret;
+
+	if (wr_len) {
+		wrmsg[i].addr  = client->addr;
+		wrmsg[i].flags = 0;
+		wrmsg[i].len = wr_len;
+		wrmsg[i].buf = wr_buf;
+		i++;
+	}
+	if (rd_len) {
+		wrmsg[i].addr  = client->addr;
+		wrmsg[i].flags = I2C_M_RD;
+		wrmsg[i].len = rd_len;
+		wrmsg[i].buf = rd_buf;
+		i++;
+	}
+
+	ret = i2c_transfer(client->adapter, wrmsg, i);
+	if (ret < 0)
+		return ret;
+	if (ret != i)
+		return -EIO;
+
+	return 0;
+}
+
+static bool edt_ft5x06_ts_check_crc(struct edt_ft5x06_ts_data *tsdata,
+				    u8 *buf, int buflen)
+{
+	int i;
+	u8 crc = 0;
+
+	for (i = 0; i < buflen - 1; i++)
+		crc ^= buf[i];
+
+	if (crc != buf[buflen-1]) {
+		dev_err_ratelimited(&tsdata->client->dev,
+				    "crc error: 0x%02x expected, got 0x%02x\n",
+				    crc, buf[buflen-1]);
+		return false;
+	}
+
+	return true;
+}
+
+static irqreturn_t edt_ft5x06_ts_isr(int irq, void *dev_id)
+{
+	struct edt_ft5x06_ts_data *tsdata = dev_id;
+	struct device *dev = &tsdata->client->dev;
+	u8 cmd = 0xf9;
+	u8 rdbuf[26];
+	int i, type, x, y, id;
+	int error;
+
+	memset(rdbuf, 0, sizeof(rdbuf));
+
+	error = edt_ft5x06_ts_readwrite(tsdata->client,
+					sizeof(cmd), &cmd,
+					sizeof(rdbuf), rdbuf);
+	if (error) {
+		dev_err_ratelimited(dev, "Unable to fetch data, error: %d\n",
+				    error);
+		goto out;
+	}
+
+	if (rdbuf[0] != 0xaa || rdbuf[1] != 0xaa || rdbuf[2] != 26) {
+		dev_err_ratelimited(dev, "Unexpected header: %02x%02x%02x!\n",
+				    rdbuf[0], rdbuf[1], rdbuf[2]);
+		goto out;
+	}
+
+	if (!edt_ft5x06_ts_check_crc(tsdata, rdbuf, 26))
+		goto out;
+
+	for (i = 0; i < MAX_SUPPORT_POINTS; i++) {
+		u8 *buf = &rdbuf[i * 4 + 5];
+		bool down;
+
+		type = buf[0] >> 6;
+		/* ignore Reserved events */
+		if (type == TOUCH_EVENT_RESERVED)
+			continue;
+
+		x = ((buf[0] << 8) | buf[1]) & 0x0fff;
+		y = ((buf[2] << 8) | buf[3]) & 0x0fff;
+		id = (buf[2] >> 4) & 0x0f;
+		down = (type != TOUCH_EVENT_UP);
+
+		input_mt_slot(tsdata->input, id);
+		input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, down);
+
+		if (!down)
+			continue;
+
+		input_report_abs(tsdata->input, ABS_MT_POSITION_X, x);
+		input_report_abs(tsdata->input, ABS_MT_POSITION_Y, y);
+	}
+
+	input_mt_report_pointer_emulation(tsdata->input, true);
+	input_sync(tsdata->input);
+
+out:
+	return IRQ_HANDLED;
+}
+
+static int edt_ft5x06_register_write(struct edt_ft5x06_ts_data *tsdata,
+				     u8 addr, u8 value)
+{
+	u8 wrbuf[4];
+
+	wrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;
+	wrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;
+	wrbuf[2] = value;
+	wrbuf[3] = wrbuf[0] ^ wrbuf[1] ^ wrbuf[2];
+
+	return edt_ft5x06_ts_readwrite(tsdata->client, 4, wrbuf, 0, NULL);
+}
+
+static int edt_ft5x06_register_read(struct edt_ft5x06_ts_data *tsdata,
+				    u8 addr)
+{
+	u8 wrbuf[2], rdbuf[2];
+	int error;
+
+	wrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;
+	wrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;
+	wrbuf[1] |= tsdata->factory_mode ? 0x80 : 0x40;
+
+	error = edt_ft5x06_ts_readwrite(tsdata->client, 2, wrbuf, 2, rdbuf);
+	if (error)
+		return error;
+
+	if ((wrbuf[0] ^ wrbuf[1] ^ rdbuf[0]) != rdbuf[1]) {
+		dev_err(&tsdata->client->dev,
+			"crc error: 0x%02x expected, got 0x%02x\n",
+			wrbuf[0] ^ wrbuf[1] ^ rdbuf[0], rdbuf[1]);
+		return -EIO;
+	}
+
+	return rdbuf[0];
+}
+
+struct edt_ft5x06_attribute {
+	struct device_attribute dattr;
+	size_t field_offset;
+	u8 limit_low;
+	u8 limit_high;
+	u8 addr;
+};
+
+#define EDT_ATTR(_field, _mode, _addr, _limit_low, _limit_high)		\
+	struct edt_ft5x06_attribute edt_ft5x06_attr_##_field = {	\
+		.dattr = __ATTR(_field, _mode,				\
+				edt_ft5x06_setting_show,		\
+				edt_ft5x06_setting_store),		\
+		.field_offset =						\
+			offsetof(struct edt_ft5x06_ts_data, _field),	\
+		.limit_low = _limit_low,				\
+		.limit_high = _limit_high,				\
+		.addr = _addr,						\
+	}
+
+static ssize_t edt_ft5x06_setting_show(struct device *dev,
+				       struct device_attribute *dattr,
+				       char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);
+	struct edt_ft5x06_attribute *attr =
+			container_of(dattr, struct edt_ft5x06_attribute, dattr);
+	u8 *field = (u8 *)((char *)tsdata + attr->field_offset);
+	int val;
+	size_t count = 0;
+	int error = 0;
+
+	mutex_lock(&tsdata->mutex);
+
+	if (tsdata->factory_mode) {
+		error = -EIO;
+		goto out;
+	}
+
+	val = edt_ft5x06_register_read(tsdata, attr->addr);
+	if (val < 0) {
+		error = val;
+		dev_err(&tsdata->client->dev,
+			"Failed to fetch attribute %s, error %d\n",
+			dattr->attr.name, error);
+		goto out;
+	}
+
+	if (val != *field) {
+		dev_warn(&tsdata->client->dev,
+			 "%s: read (%d) and stored value (%d) differ\n",
+			 dattr->attr.name, val, *field);
+		*field = val;
+	}
+
+	count = scnprintf(buf, PAGE_SIZE, "%d\n", val);
+out:
+	mutex_unlock(&tsdata->mutex);
+	return error ?: count;
+}
+
+static ssize_t edt_ft5x06_setting_store(struct device *dev,
+					struct device_attribute *dattr,
+					const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);
+	struct edt_ft5x06_attribute *attr =
+			container_of(dattr, struct edt_ft5x06_attribute, dattr);
+	u8 *field = (u8 *)((char *)tsdata + attr->field_offset);
+	unsigned int val;
+	int error;
+
+	mutex_lock(&tsdata->mutex);
+
+	if (tsdata->factory_mode) {
+		error = -EIO;
+		goto out;
+	}
+
+	error = kstrtouint(buf, 0, &val);
+	if (error)
+		goto out;
+
+	if (val < attr->limit_low || val > attr->limit_high) {
+		error = -ERANGE;
+		goto out;
+	}
+
+	error = edt_ft5x06_register_write(tsdata, attr->addr, val);
+	if (error) {
+		dev_err(&tsdata->client->dev,
+			"Failed to update attribute %s, error: %d\n",
+			dattr->attr.name, error);
+		goto out;
+	}
+
+	*field = val;
+
+out:
+	mutex_unlock(&tsdata->mutex);
+	return error ?: count;
+}
+
+static EDT_ATTR(gain, S_IWUSR | S_IRUGO, WORK_REGISTER_GAIN, 0, 31);
+static EDT_ATTR(offset, S_IWUSR | S_IRUGO, WORK_REGISTER_OFFSET, 0, 31);
+static EDT_ATTR(threshold, S_IWUSR | S_IRUGO,
+		WORK_REGISTER_THRESHOLD, 20, 80);
+static EDT_ATTR(report_rate, S_IWUSR | S_IRUGO,
+		WORK_REGISTER_REPORT_RATE, 3, 14);
+
+static struct attribute *edt_ft5x06_attrs[] = {
+	&edt_ft5x06_attr_gain.dattr.attr,
+	&edt_ft5x06_attr_offset.dattr.attr,
+	&edt_ft5x06_attr_threshold.dattr.attr,
+	&edt_ft5x06_attr_report_rate.dattr.attr,
+	NULL
+};
+
+static const struct attribute_group edt_ft5x06_attr_group = {
+	.attrs = edt_ft5x06_attrs,
+};
+
+#ifdef CONFIG_DEBUG_FS
+static int edt_ft5x06_factory_mode(struct edt_ft5x06_ts_data *tsdata)
+{
+	struct i2c_client *client = tsdata->client;
+	int retries = EDT_SWITCH_MODE_RETRIES;
+	int ret;
+	int error;
+
+	disable_irq(client->irq);
+
+	if (!tsdata->raw_buffer) {
+		tsdata->raw_bufsize = tsdata->num_x * tsdata->num_y *
+				      sizeof(u16);
+		tsdata->raw_buffer = kzalloc(tsdata->raw_bufsize, GFP_KERNEL);
+		if (!tsdata->raw_buffer) {
+			error = -ENOMEM;
+			goto err_out;
+		}
+	}
+
+	/* mode register is 0x3c when in the work mode */
+	error = edt_ft5x06_register_write(tsdata, WORK_REGISTER_OPMODE, 0x03);
+	if (error) {
+		dev_err(&client->dev,
+			"failed to switch to factory mode, error %d\n", error);
+		goto err_out;
+	}
+
+	tsdata->factory_mode = true;
+	do {
+		mdelay(EDT_SWITCH_MODE_DELAY);
+		/* mode register is 0x01 when in factory mode */
+		ret = edt_ft5x06_register_read(tsdata, FACTORY_REGISTER_OPMODE);
+		if (ret == 0x03)
+			break;
+	} while (--retries > 0);
+
+	if (retries == 0) {
+		dev_err(&client->dev, "not in factory mode after %dms.\n",
+			EDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);
+		error = -EIO;
+		goto err_out;
+	}
+
+	return 0;
+
+err_out:
+	kfree(tsdata->raw_buffer);
+	tsdata->raw_buffer = NULL;
+	tsdata->factory_mode = false;
+	enable_irq(client->irq);
+
+	return error;
+}
+
+static int edt_ft5x06_work_mode(struct edt_ft5x06_ts_data *tsdata)
+{
+	struct i2c_client *client = tsdata->client;
+	int retries = EDT_SWITCH_MODE_RETRIES;
+	int ret;
+	int error;
+
+	/* mode register is 0x01 when in the factory mode */
+	error = edt_ft5x06_register_write(tsdata, FACTORY_REGISTER_OPMODE, 0x1);
+	if (error) {
+		dev_err(&client->dev,
+			"failed to switch to work mode, error: %d\n", error);
+		return error;
+	}
+
+	tsdata->factory_mode = false;
+
+	do {
+		mdelay(EDT_SWITCH_MODE_DELAY);
+		/* mode register is 0x01 when in factory mode */
+		ret = edt_ft5x06_register_read(tsdata, WORK_REGISTER_OPMODE);
+		if (ret == 0x01)
+			break;
+	} while (--retries > 0);
+
+	if (retries == 0) {
+		dev_err(&client->dev, "not in work mode after %dms.\n",
+			EDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);
+		tsdata->factory_mode = true;
+		return -EIO;
+	}
+
+	if (tsdata->raw_buffer)
+		kfree(tsdata->raw_buffer);
+	tsdata->raw_buffer = NULL;
+
+	/* restore parameters */
+	edt_ft5x06_register_write(tsdata, WORK_REGISTER_THRESHOLD,
+				  tsdata->threshold);
+	edt_ft5x06_register_write(tsdata, WORK_REGISTER_GAIN,
+				  tsdata->gain);
+	edt_ft5x06_register_write(tsdata, WORK_REGISTER_OFFSET,
+				  tsdata->offset);
+	edt_ft5x06_register_write(tsdata, WORK_REGISTER_REPORT_RATE,
+				  tsdata->report_rate);
+
+	enable_irq(client->irq);
+
+	return 0;
+}
+
+static int edt_ft5x06_debugfs_mode_get(void *data, u64 *mode)
+{
+	struct edt_ft5x06_ts_data *tsdata = data;
+
+	*mode = tsdata->factory_mode;
+
+	return 0;
+};
+
+static int edt_ft5x06_debugfs_mode_set(void *data, u64 mode)
+{
+	struct edt_ft5x06_ts_data *tsdata = data;
+	int retval = 0;
+
+	if (mode > 1)
+		return -ERANGE;
+
+	mutex_lock(&tsdata->mutex);
+
+	if (mode != tsdata->factory_mode) {
+		retval = mode ? edt_ft5x06_factory_mode(tsdata) :
+				edt_ft5x06_work_mode(tsdata);
+	}
+
+	mutex_unlock(&tsdata->mutex);
+
+	return retval;
+};
+
+DEFINE_SIMPLE_ATTRIBUTE(debugfs_mode_fops, edt_ft5x06_debugfs_mode_get,
+			edt_ft5x06_debugfs_mode_set, "%llu\n");
+
+static int edt_ft5x06_debugfs_raw_data_open(struct inode *inode,
+					    struct file *file)
+{
+	file->private_data = inode->i_private;
+
+	return 0;
+}
+
+static ssize_t edt_ft5x06_debugfs_raw_data_read(struct file *file,
+				char __user *buf, size_t count, loff_t *off)
+{
+	struct edt_ft5x06_ts_data *tsdata = file->private_data;
+	struct i2c_client *client = tsdata->client;
+	int retries  = EDT_RAW_DATA_RETRIES;
+	int val, i, error;
+	size_t read = 0;
+	int colbytes;
+	char wrbuf[3];
+	u8 *rdbuf;
+
+	if (*off < 0 || *off >= tsdata->raw_bufsize)
+		return 0;
+
+	mutex_lock(&tsdata->mutex);
+
+	if (!tsdata->factory_mode || !tsdata->raw_buffer) {
+		error = -EIO;
+		goto out;
+	}
+
+	error = edt_ft5x06_register_write(tsdata, 0x08, 0x01);
+	if (error) {
+		dev_dbg(&client->dev,
+			"failed to write 0x08 register, error %d\n", error);
+		goto out;
+	}
+
+	do {
+		msleep(EDT_RAW_DATA_DELAY);
+		val = edt_ft5x06_register_read(tsdata, 0x08);
+		if (val < 1)
+			break;
+	} while (--retries > 0);
+
+	if (val < 0) {
+		error = val;
+		dev_dbg(&client->dev,
+			"failed to read 0x08 register, error %d\n", error);
+		goto out;
+	}
+
+	if (retries == 0) {
+		dev_dbg(&client->dev,
+			"timed out waiting for register to settle\n");
+		error = -ETIMEDOUT;
+		goto out;
+	}
+
+	rdbuf = tsdata->raw_buffer;
+	colbytes = tsdata->num_y * sizeof(u16);
+
+	wrbuf[0] = 0xf5;
+	wrbuf[1] = 0x0e;
+	for (i = 0; i < tsdata->num_x; i++) {
+		wrbuf[2] = i;  /* column index */
+		error = edt_ft5x06_ts_readwrite(tsdata->client,
+						sizeof(wrbuf), wrbuf,
+						colbytes, rdbuf);
+		if (error)
+			goto out;
+
+		rdbuf += colbytes;
+	}
+
+	read = min_t(size_t, count, tsdata->raw_bufsize - *off);
+	error = copy_to_user(buf, tsdata->raw_buffer + *off, read);
+	if (!error)
+		*off += read;
+out:
+	mutex_unlock(&tsdata->mutex);
+	return error ?: read;
+};
+
+
+static const struct file_operations debugfs_raw_data_fops = {
+	.open = edt_ft5x06_debugfs_raw_data_open,
+	.read = edt_ft5x06_debugfs_raw_data_read,
+};
+
+static void __devinit
+edt_ft5x06_ts_prepare_debugfs(struct edt_ft5x06_ts_data *tsdata,
+			      const char *debugfs_name)
+{
+	tsdata->debug_dir = debugfs_create_dir(debugfs_name, NULL);
+	if (!tsdata->debug_dir)
+		return;
+
+	debugfs_create_u16("num_x", S_IRUSR, tsdata->debug_dir, &tsdata->num_x);
+	debugfs_create_u16("num_y", S_IRUSR, tsdata->debug_dir, &tsdata->num_y);
+
+	debugfs_create_file("mode", S_IRUSR | S_IWUSR,
+			    tsdata->debug_dir, tsdata, &debugfs_mode_fops);
+	debugfs_create_file("raw_data", S_IRUSR,
+			    tsdata->debug_dir, tsdata, &debugfs_raw_data_fops);
+}
+
+static void __devexit
+edt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)
+{
+	if (tsdata->debug_dir)
+		debugfs_remove_recursive(tsdata->debug_dir);
+	kfree(tsdata->raw_buffer);
+}
+
+#else
+
+static inline void
+edt_ft5x06_ts_prepare_debugfs(struct edt_ft5x06_ts_data *tsdata,
+			      const char *debugfs_name)
+{
+}
+
+static inline void
+edt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)
+{
+}
+
+#endif /* CONFIG_DEBUGFS */
+
+
+
+static int __devinit edt_ft5x06_ts_reset(struct i2c_client *client,
+					 int reset_pin)
+{
+	int error;
+
+	if (gpio_is_valid(reset_pin)) {
+		/* this pulls reset down, enabling the low active reset */
+		error = gpio_request_one(reset_pin, GPIOF_OUT_INIT_LOW,
+					 "edt-ft5x06 reset");
+		if (error) {
+			dev_err(&client->dev,
+				"Failed to request GPIO %d as reset pin, error %d\n",
+				reset_pin, error);
+			return error;
+		}
+
+		mdelay(50);
+		gpio_set_value(reset_pin, 1);
+		mdelay(100);
+	}
+
+	return 0;
+}
+
+static int __devinit edt_ft5x06_ts_identify(struct i2c_client *client,
+					    char *model_name,
+					    char *fw_version)
+{
+	u8 rdbuf[EDT_NAME_LEN];
+	char *p;
+	int error;
+
+	error = edt_ft5x06_ts_readwrite(client, 1, "\xbb",
+					EDT_NAME_LEN - 1, rdbuf);
+	if (error)
+		return error;
+
+	/* remove last '$' end marker */
+	rdbuf[EDT_NAME_LEN - 1] = '\0';
+	if (rdbuf[EDT_NAME_LEN - 2] == '$')
+		rdbuf[EDT_NAME_LEN - 2] = '\0';
+
+	/* look for Model/Version separator */
+	p = strchr(rdbuf, '*');
+	if (p)
+		*p++ = '\0';
+
+	strlcpy(model_name, rdbuf + 1, EDT_NAME_LEN);
+	strlcpy(fw_version, p ? p : "", EDT_NAME_LEN);
+
+	return 0;
+}
+
+#define EDT_ATTR_CHECKSET(name, reg) \
+	if (pdata->name >= edt_ft5x06_attr_##name.limit_low &&		\
+	    pdata->name <= edt_ft5x06_attr_##name.limit_high)		\
+		edt_ft5x06_register_write(tsdata, reg, pdata->name)
+
+static void __devinit
+edt_ft5x06_ts_get_defaults(struct edt_ft5x06_ts_data *tsdata,
+			   const struct edt_ft5x06_platform_data *pdata)
+{
+	if (!pdata->use_parameters)
+		return;
+
+	/* pick up defaults from the platform data */
+	EDT_ATTR_CHECKSET(threshold, WORK_REGISTER_THRESHOLD);
+	EDT_ATTR_CHECKSET(gain, WORK_REGISTER_GAIN);
+	EDT_ATTR_CHECKSET(offset, WORK_REGISTER_OFFSET);
+	EDT_ATTR_CHECKSET(report_rate, WORK_REGISTER_REPORT_RATE);
+}
+
+static void __devinit
+edt_ft5x06_ts_get_parameters(struct edt_ft5x06_ts_data *tsdata)
+{
+	tsdata->threshold = edt_ft5x06_register_read(tsdata,
+						     WORK_REGISTER_THRESHOLD);
+	tsdata->gain = edt_ft5x06_register_read(tsdata, WORK_REGISTER_GAIN);
+	tsdata->offset = edt_ft5x06_register_read(tsdata, WORK_REGISTER_OFFSET);
+	tsdata->report_rate = edt_ft5x06_register_read(tsdata,
+						WORK_REGISTER_REPORT_RATE);
+	tsdata->num_x = edt_ft5x06_register_read(tsdata, WORK_REGISTER_NUM_X);
+	tsdata->num_y = edt_ft5x06_register_read(tsdata, WORK_REGISTER_NUM_Y);
+}
+
+static int __devinit edt_ft5x06_ts_probe(struct i2c_client *client,
+					 const struct i2c_device_id *id)
+{
+	const struct edt_ft5x06_platform_data *pdata =
+						client->dev.platform_data;
+	struct edt_ft5x06_ts_data *tsdata;
+	struct input_dev *input;
+	int error;
+	char fw_version[EDT_NAME_LEN];
+
+	dev_dbg(&client->dev, "probing for EDT FT5x06 I2C\n");
+
+	if (!pdata) {
+		dev_err(&client->dev, "no platform data?\n");
+		return -EINVAL;
+	}
+
+	error = edt_ft5x06_ts_reset(client, pdata->reset_pin);
+	if (error)
+		return error;
+
+	if (gpio_is_valid(pdata->irq_pin)) {
+		error = gpio_request_one(pdata->irq_pin,
+					 GPIOF_IN, "edt-ft5x06 irq");
+		if (error) {
+			dev_err(&client->dev,
+				"Failed to request GPIO %d, error %d\n",
+				pdata->irq_pin, error);
+			return error;
+		}
+	}
+
+	tsdata = kzalloc(sizeof(*tsdata), GFP_KERNEL);
+	input = input_allocate_device();
+	if (!tsdata || !input) {
+		dev_err(&client->dev, "failed to allocate driver data.\n");
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	mutex_init(&tsdata->mutex);
+	tsdata->client = client;
+	tsdata->input = input;
+	tsdata->factory_mode = false;
+
+	error = edt_ft5x06_ts_identify(client, tsdata->name, fw_version);
+	if (error) {
+		dev_err(&client->dev, "touchscreen probe failed\n");
+		goto err_free_mem;
+	}
+
+	edt_ft5x06_ts_get_defaults(tsdata, pdata);
+	edt_ft5x06_ts_get_parameters(tsdata);
+
+	dev_dbg(&client->dev,
+		"Model \"%s\", Rev. \"%s\", %dx%d sensors\n",
+		tsdata->name, fw_version, tsdata->num_x, tsdata->num_y);
+
+	input->name = tsdata->name;
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &client->dev;
+
+	__set_bit(EV_SYN, input->evbit);
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(BTN_TOUCH, input->keybit);
+	input_set_abs_params(input, ABS_X, 0, tsdata->num_x * 64 - 1, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, tsdata->num_y * 64 - 1, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_X,
+			     0, tsdata->num_x * 64 - 1, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y,
+			     0, tsdata->num_y * 64 - 1, 0, 0);
+	error = input_mt_init_slots(input, MAX_SUPPORT_POINTS);
+	if (error) {
+		dev_err(&client->dev, "Unable to init MT slots.\n");
+		goto err_free_mem;
+	}
+
+	input_set_drvdata(input, tsdata);
+	i2c_set_clientdata(client, tsdata);
+
+	error = request_threaded_irq(client->irq, NULL, edt_ft5x06_ts_isr,
+				     IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				     client->name, tsdata);
+	if (error) {
+		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");
+		goto err_free_mem;
+	}
+
+	error = sysfs_create_group(&client->dev.kobj, &edt_ft5x06_attr_group);
+	if (error)
+		goto err_free_irq;
+
+	error = input_register_device(input);
+	if (error)
+		goto err_remove_attrs;
+
+	edt_ft5x06_ts_prepare_debugfs(tsdata, dev_driver_string(&client->dev));
+	device_init_wakeup(&client->dev, 1);
+
+	dev_dbg(&client->dev,
+		"EDT FT5x06 initialized: IRQ pin %d, Reset pin %d.\n",
+		pdata->irq_pin, pdata->reset_pin);
+
+	return 0;
+
+err_remove_attrs:
+	sysfs_remove_group(&client->dev.kobj, &edt_ft5x06_attr_group);
+err_free_irq:
+	free_irq(client->irq, tsdata);
+err_free_mem:
+	input_free_device(input);
+	kfree(tsdata);
+
+	if (gpio_is_valid(pdata->irq_pin))
+		gpio_free(pdata->irq_pin);
+
+	return error;
+}
+
+static int __devexit edt_ft5x06_ts_remove(struct i2c_client *client)
+{
+	const struct edt_ft5x06_platform_data *pdata =
+						dev_get_platdata(&client->dev);
+	struct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);
+
+	edt_ft5x06_ts_teardown_debugfs(tsdata);
+	sysfs_remove_group(&client->dev.kobj, &edt_ft5x06_attr_group);
+
+	free_irq(client->irq, tsdata);
+	input_unregister_device(tsdata->input);
+
+	if (gpio_is_valid(pdata->irq_pin))
+		gpio_free(pdata->irq_pin);
+	if (gpio_is_valid(pdata->reset_pin))
+		gpio_free(pdata->reset_pin);
+
+	kfree(tsdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int edt_ft5x06_ts_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(client->irq);
+
+	return 0;
+}
+
+static int edt_ft5x06_ts_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (device_may_wakeup(dev))
+		disable_irq_wake(client->irq);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(edt_ft5x06_ts_pm_ops,
+			 edt_ft5x06_ts_suspend, edt_ft5x06_ts_resume);
+
+static const struct i2c_device_id edt_ft5x06_ts_id[] = {
+	{ "edt-ft5x06", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, edt_ft5x06_ts_id);
+
+static struct i2c_driver edt_ft5x06_ts_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "edt_ft5x06",
+		.pm = &edt_ft5x06_ts_pm_ops,
+	},
+	.id_table = edt_ft5x06_ts_id,
+	.probe    = edt_ft5x06_ts_probe,
+	.remove   = __devexit_p(edt_ft5x06_ts_remove),
+};
+
+
+static int __init edt_ft5x06_i2c_ts_init(void)
+{
+	return i2c_add_driver(&edt_ft5x06_ts_driver);
+}
+module_init(edt_ft5x06_i2c_ts_init);
+
+static void __exit edt_ft5x06_i2c_ts_exit(void)
+{
+	i2c_del_driver(&edt_ft5x06_ts_driver);
+}
+module_exit(edt_ft5x06_i2c_ts_exit);
+
+MODULE_AUTHOR("Simon Budig <simon.budig@kernelconcepts.de>");
+MODULE_DESCRIPTION("EDT FT5x06 I2C Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/tps65910-irq.c b/drivers/mfd/tps65910-irq.c
index a56be93..566b4ee 100644
--- a/drivers/mfd/tps65910-irq.c
+++ b/drivers/mfd/tps65910-irq.c
@@ -205,7 +205,7 @@ int tps65910_irq_init(struct tps65910 *tps65910, int irq,
 	ret = request_threaded_irq(irq, NULL, tps65910_irq, flags,
 				   "tps65910", tps65910);
 
-	irq_set_irq_type(irq, IRQ_TYPE_LEVEL_LOW);
+	irq_set_irq_type(irq, IRQ_TYPE_LEVEL_HIGH);
 
 	if (ret != 0)
 		dev_err(tps65910->dev, "Failed to request IRQ: %d\n", ret);
diff --git a/drivers/mfd/tps65910.c b/drivers/mfd/tps65910.c
index 2d4bc21..1c5bc3d 100644
--- a/drivers/mfd/tps65910.c
+++ b/drivers/mfd/tps65910.c
@@ -21,13 +21,27 @@
 #include <linux/mfd/core.h>
 #include <linux/mfd/tps65910.h>
 
+#ifdef CONFIG_RTC_DRV_TPS65910
+static struct resource rtc_resources[] = {
+	{
+		.name = "tps65910-rtc",
+		.flags = IORESOURCE_IRQ,
+		.start = 0,		/* filled in later */
+	},
+};
+#endif
+
 static struct mfd_cell tps65910s[] = {
 	{
 		.name = "tps65910-pmic",
 	},
+#ifdef CONFIG_RTC_DRV_TPS65910
 	{
 		.name = "tps65910-rtc",
+		.resources = rtc_resources,
+		.num_resources = ARRAY_SIZE(rtc_resources),
 	},
+#endif
 	{
 		.name = "tps65910-power",
 	},
@@ -162,7 +176,7 @@ static int tps65910_i2c_probe(struct i2c_client *i2c,
 	mutex_init(&tps65910->io_mutex);
 
 	/* Check that the device is actually there */
-	ret = tps65910_i2c_read(tps65910, 0x0, 1, &buff);
+	ret = tps65910_i2c_read(tps65910, 0x80, 1, &buff);
 	if (ret < 0) {
 		dev_err(tps65910->dev, "could not be detected\n");
 		ret = -ENODEV;
@@ -177,13 +191,26 @@ static int tps65910_i2c_probe(struct i2c_client *i2c,
 		goto err;
 	}
 
+#ifdef CONFIG_RTC_DRV_TPS65910
+	rtc_resources[0].start = TWL4030_IRQ_BASE + TPS65910_IRQ_RTC_ALARM;
+
+	/* Use external oscillator */
+	tps65910_clear_bits(tps65910, TPS65910_DEVCTRL, 0x20);
+	/* Clear RTC_PWDN bit */
+	tps65910_clear_bits(tps65910, TPS65910_DEVCTRL, 0x40);
+#else
+	/* Set RTC_PWDN bit */
+	tps65910_set_bits(tps65910, TPS65910_DEVCTRL, 0x40);
+#endif
 	ret = mfd_add_devices(tps65910->dev, -1, tps65910s,
 			ARRAY_SIZE(tps65910s), NULL, 0);
 	if (ret < 0)
 		goto err;
 
 	init_data->irq = pmic_plat_data->irq;
-	init_data->irq_base = pmic_plat_data->irq_base;
+	init_data->irq_base = TWL4030_IRQ_BASE;
+	tps65910->irq_base = TWL4030_IRQ_BASE;
+	tps65910->irq_num = TWL4030_BASE_NR_IRQS;
 
 	tps65910_gpio_init(tps65910, pmic_plat_data->gpio_base);
 
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index a5df3ec..c22665d 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -338,7 +338,7 @@ static int nand_verify_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
  */
 static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 {
-	int page, chipnr, res = 0;
+	int page, chipnr, res = 0, i = 0;
 	struct nand_chip *chip = mtd->priv;
 	u16 bad;
 
@@ -356,23 +356,29 @@ static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 		chip->select_chip(mtd, chipnr);
 	}
 
-	if (chip->options & NAND_BUSWIDTH_16) {
-		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos & 0xFE,
-			      page);
-		bad = cpu_to_le16(chip->read_word(mtd));
-		if (chip->badblockpos & 0x1)
-			bad >>= 8;
-		else
-			bad &= 0xFF;
-	} else {
-		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos, page);
-		bad = chip->read_byte(mtd);
-	}
+	do {
+		if (chip->options & NAND_BUSWIDTH_16) {
+			chip->cmdfunc(mtd, NAND_CMD_READOOB,
+					chip->badblockpos & 0xFE, page);
+			bad = cpu_to_le16(chip->read_word(mtd));
+			if (chip->badblockpos & 0x1)
+				bad >>= 8;
+			else
+				bad &= 0xFF;
+		} else {
+			chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos,
+					page);
+			bad = chip->read_byte(mtd);
+		}
 
-	if (likely(chip->badblockbits == 8))
-		res = bad != 0xFF;
-	else
-		res = hweight8(bad) < chip->badblockbits;
+		if (likely(chip->badblockbits == 8))
+			res = bad != 0xFF;
+		else
+			res = hweight8(bad) < chip->badblockbits;
+		ofs += mtd->writesize;
+		page = (int)(ofs >> chip->page_shift) & chip->pagemask;
+		i++;
+	} while (!res && i < 2 && (chip->bbt_options & NAND_BBT_SCAN2NDPAGE));
 
 	if (getchip)
 		nand_release_device(mtd);
@@ -578,17 +584,18 @@ static void nand_command(struct mtd_info *mtd, unsigned int command,
 	}
 	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
-	/*
-	 * Program and erase have their own busy handlers status and sequential
-	 * in needs no delay
-	 */
+	/* Some commands need no delay */
 	switch (command) {
 
-	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_ERASE1:
-	case NAND_CMD_ERASE2:
+		return;
+
 	case NAND_CMD_SEQIN:
+		ndelay(70);	/* need to wait tADL, but ready line not used */
+		return;
+
 	case NAND_CMD_STATUS:
+		ndelay(80);	/* need to wait tWHR, but ready line not used */
 		return;
 
 	case NAND_CMD_RESET:
@@ -611,7 +618,7 @@ static void nand_command(struct mtd_info *mtd, unsigned int command,
 		 */
 		if (!chip->dev_ready) {
 			udelay(chip->chip_delay);
-			return;
+			goto afterready;
 		}
 	}
 	/*
@@ -621,6 +628,10 @@ static void nand_command(struct mtd_info *mtd, unsigned int command,
 	ndelay(100);
 
 	nand_wait_ready(mtd);
+
+afterready:
+	if (command == NAND_CMD_READ0)
+		ndelay(20);	/* need to wait tRR after chip is ready */
 }
 
 /**
@@ -673,22 +684,23 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 	}
 	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
-	/*
-	 * Program and erase have their own busy handlers status, sequential
-	 * in, and deplete1 need no delay.
-	 */
 	switch (command) {
 
+	/* Some commands need no delay */
 	case NAND_CMD_CACHEDPROG:
-	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_ERASE1:
-	case NAND_CMD_ERASE2:
-	case NAND_CMD_SEQIN:
 	case NAND_CMD_RNDIN:
-	case NAND_CMD_STATUS:
 	case NAND_CMD_DEPLETE1:
 		return;
 
+	case NAND_CMD_SEQIN:
+		ndelay(70);	/* need to wait tADL, but ready line not used */
+		return;
+
+	case NAND_CMD_STATUS:
+		ndelay(80);	/* need to wait tWHR, but ready line not used */
+		return;
+
 	case NAND_CMD_STATUS_ERROR:
 	case NAND_CMD_STATUS_ERROR0:
 	case NAND_CMD_STATUS_ERROR1:
@@ -716,6 +728,7 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
 		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
 			       NAND_NCE | NAND_CTRL_CHANGE);
+		ndelay(80);	/* tWHR */
 		return;
 
 	case NAND_CMD_READ0:
@@ -734,7 +747,7 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 		 */
 		if (!chip->dev_ready) {
 			udelay(chip->chip_delay);
-			return;
+			goto afterready;
 		}
 	}
 
@@ -745,6 +758,10 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 	ndelay(100);
 
 	nand_wait_ready(mtd);
+
+afterready:
+	if (command == NAND_CMD_READ0)
+		ndelay(20);	/* need to wait tRR after chip is ready */
 }
 
 /**
@@ -2901,7 +2918,8 @@ static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,
 	mtd->writesize = le32_to_cpu(p->byte_per_page);
 	mtd->erasesize = le32_to_cpu(p->pages_per_block) * mtd->writesize;
 	mtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);
-	chip->chipsize = (uint64_t)le32_to_cpu(p->blocks_per_lun) * mtd->erasesize;
+	chip->chipsize = le32_to_cpu(p->blocks_per_lun);
+	chip->chipsize *= (uint64_t)mtd->erasesize * p->lun_count;
 	*busw = 0;
 	if (le16_to_cpu(p->features) & 1)
 		*busw = NAND_BUSWIDTH_16;
diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 559e945..f709971 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -943,14 +943,13 @@ static void _cpsw_adjust_link(struct cpsw_slave *slave,
 		mac_control = priv->data.mac_control;
 		if (phy->speed == 10)
 			mac_control |= BIT(18); /* In Band mode */
-		if (phy->speed == 1000) {
+		if (phy->speed == 1000)
 			mac_control |= BIT(7);	/* Enable gigabit mode */
-		}
 		if (phy->speed == 100)
 			mac_control |= BIT(15);
 		if (phy->duplex)
 			mac_control |= BIT(0);	/* FULLDUPLEXEN	*/
-		if (phy->interface == PHY_INTERFACE_MODE_RGMII) /* RGMII */
+		if (phy->interface != PHY_INTERFACE_MODE_MII) /* RGMII or RMII*/
 			mac_control |= (BIT(15)|BIT(16));
 		*link = true;
 	} else {
diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c
index 590f902..c3bc7cfc 100644
--- a/drivers/net/phy/micrel.c
+++ b/drivers/net/phy/micrel.c
@@ -161,7 +161,7 @@ static struct phy_driver ks8051_driver = {
 static struct phy_driver ks8001_driver = {
 	.phy_id		= PHY_ID_KS8001,
 	.name		= "Micrel KS8001 or KS8721",
-	.phy_id_mask	= 0x00fffff0,
+	.phy_id_mask	= 0x00ffffff,
 	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
 	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
 	.config_init	= kszphy_config_init,
@@ -174,8 +174,22 @@ static struct phy_driver ks8001_driver = {
 
 static struct phy_driver ksz9021_driver = {
 	.phy_id		= PHY_ID_KSZ9021,
-	.phy_id_mask	= 0x000fff10,
+	.phy_id_mask	= 0x000ffffe,
 	.name		= "Micrel KSZ9021 Gigabit PHY",
+	.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= ksz9021_config_intr,
+	.driver		= { .owner = THIS_MODULE, },
+};
+
+static struct phy_driver ksz9031_driver = {
+	.phy_id		= PHY_ID_KSZ9031,
+	.phy_id_mask	= 0x000ffffe,
+	.name		= "Micrel KSZ9031 Gigabit PHY",
 	.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause
 				| SUPPORTED_Asym_Pause),
 	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
@@ -199,22 +213,28 @@ static int __init ksphy_init(void)
 	if (ret)
 		goto err2;
 
-	ret = phy_driver_register(&ks8737_driver);
+	ret = phy_driver_register(&ksz9031_driver);
 	if (ret)
 		goto err3;
-	ret = phy_driver_register(&ks8041_driver);
+
+	ret = phy_driver_register(&ks8737_driver);
 	if (ret)
 		goto err4;
-	ret = phy_driver_register(&ks8051_driver);
+	ret = phy_driver_register(&ks8041_driver);
 	if (ret)
 		goto err5;
+	ret = phy_driver_register(&ks8051_driver);
+	if (ret)
+		goto err6;
 
 	return 0;
 
-err5:
+err6:
 	phy_driver_unregister(&ks8041_driver);
-err4:
+err5:
 	phy_driver_unregister(&ks8737_driver);
+err4:
+	phy_driver_unregister(&ksz9031_driver);
 err3:
 	phy_driver_unregister(&ksz9021_driver);
 err2:
@@ -228,6 +248,7 @@ static void __exit ksphy_exit(void)
 	phy_driver_unregister(&ks8001_driver);
 	phy_driver_unregister(&ks8737_driver);
 	phy_driver_unregister(&ksz9021_driver);
+	phy_driver_unregister(&ksz9031_driver);
 	phy_driver_unregister(&ks8041_driver);
 	phy_driver_unregister(&ks8051_driver);
 }
@@ -240,8 +261,9 @@ MODULE_AUTHOR("David J. Choi");
 MODULE_LICENSE("GPL");
 
 static struct mdio_device_id __maybe_unused micrel_tbl[] = {
-	{ PHY_ID_KSZ9021, 0x000fff10 },
-	{ PHY_ID_KS8001, 0x00fffff0 },
+	{ PHY_ID_KSZ9031, 0x000ffffe },
+	{ PHY_ID_KSZ9021, 0x000ffffe },
+	{ PHY_ID_KS8001, 0x00ffffff },
 	{ PHY_ID_KS8737, 0x00fffff0 },
 	{ PHY_ID_KS8041, 0x00fffff0 },
 	{ PHY_ID_KS8051, 0x00fffff0 },
diff --git a/drivers/net/wireless/wl12xx/main.c b/drivers/net/wireless/wl12xx/main.c
index 884f82b..ac85294 100644
--- a/drivers/net/wireless/wl12xx/main.c
+++ b/drivers/net/wireless/wl12xx/main.c
@@ -32,6 +32,7 @@
 #include <linux/slab.h>
 #include <linux/wl12xx.h>
 #include <linux/sched.h>
+#include <linux/gpio.h>
 
 #include "wl12xx.h"
 #include "wl12xx_80211.h"
@@ -1837,6 +1838,10 @@ static u8 wl12xx_get_role_type(struct wl1271 *wl)
 	return WL12XX_INVALID_ROLE_TYPE;
 }
 
+#ifdef CONFIG_MACH_PCM051
+#define WLAN_EN          56 /* 32 * bank (1) + gpio (24)*/
+#endif
+
 static int wl1271_op_add_interface(struct ieee80211_hw *hw,
 				   struct ieee80211_vif *vif)
 {
@@ -1849,6 +1854,9 @@ static int wl1271_op_add_interface(struct ieee80211_hw *hw,
 
 	wl1271_debug(DEBUG_MAC80211, "mac80211 add interface type %d mac %pM",
 		     ieee80211_vif_type_p2p(vif), vif->addr);
+#ifdef CONFIG_MACH_PCM051
+	gpio_direction_output(WLAN_EN, 1);
+#endif
 
 	mutex_lock(&wl->mutex);
 	if (wl->vif) {
@@ -1985,6 +1993,10 @@ power_off:
 		     wl->enable_11a ? "" : "not ");
 
 out:
+#ifdef CONFIG_MACH_PCM051
+	if (ret < 0)
+		gpio_direction_output(WLAN_EN, 0);
+#endif
 	mutex_unlock(&wl->mutex);
 
 	mutex_lock(&wl_list_mutex);
@@ -4607,6 +4619,7 @@ static struct bin_attribute fwlog_attr = {
 int wl1271_register_hw(struct wl1271 *wl)
 {
 	int ret;
+	static const u8 nokia_oui[3] = {0x00, 0x1f, 0xdf};
 
 	if (wl->mac80211_registered)
 		return 0;
@@ -4625,6 +4638,13 @@ int wl1271_register_hw(struct wl1271 *wl)
 		wl->mac_addr[3] = nvs_ptr[5];
 		wl->mac_addr[4] = nvs_ptr[4];
 		wl->mac_addr[5] = nvs_ptr[3];
+		/*
+		 * We can't use the Ethernet address in the nvs file as it
+		 * is not specific to this station.  Rather, generate a
+		 * random address as the old wl12xx driver used to do.
+		 */
+		memcpy(wl->mac_addr, nokia_oui, 3);
+		get_random_bytes(wl->mac_addr + 3, 3);
 	}
 
 	SET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 34a7129..a432976 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -272,12 +272,12 @@ config RTC_DRV_PCF8583
 	  will be called rtc-pcf8583.
 
 config RTC_DRV_M41T80
-	tristate "ST M41T62/65/M41T80/81/82/83/84/85/87"
+	tristate "ST M41T62/65/M41T80/81/82/83/84/85/87 RV-4162-C7"
 	help
 	  If you say Y here you will get support for the ST M41T60
 	  and M41T80 RTC chips series. Currently, the following chips are
 	  supported: M41T62, M41T65, M41T80, M41T81, M41T82, M41T83, M41ST84,
-	  M41ST85, and M41ST87.
+	  M41ST85, M41ST87 and RV-4162-C7 from Micro Crystal.
 
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-m41t80.
@@ -314,7 +314,7 @@ config RTC_DRV_TWL92330
 	  the Menelaus driver; it's not separate module.
 
 config RTC_DRV_TWL4030
-	tristate "TI TWL4030/TWL5030/TWL6030/TPS659x0"
+	tristate "TI TWL4030/TWL5030/TWL6030"
 	depends on RTC_CLASS && TWL4030_CORE
 	help
 	  If you say yes here you get support for the RTC on the
@@ -323,6 +323,13 @@ config RTC_DRV_TWL4030
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-twl.
 
+config RTC_DRV_TPS65910
+	tristate "TI TPS65910"
+	depends on RTC_CLASS && MFD_TPS65910
+	help
+	  If you say yes here you get support for the RTC on the
+	  TPS65910.
+
 config RTC_DRV_S35390A
 	tristate "Seiko Instruments S-35390A"
 	select BITREVERSE
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 6e69823..8ea5724 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -102,6 +102,7 @@ obj-$(CONFIG_RTC_DRV_TEGRA)	+= rtc-tegra.o
 obj-$(CONFIG_RTC_DRV_TEST)	+= rtc-test.o
 obj-$(CONFIG_RTC_DRV_TILE)	+= rtc-tile.o
 obj-$(CONFIG_RTC_DRV_TWL4030)	+= rtc-twl.o
+obj-$(CONFIG_RTC_DRV_TPS65910)	+= rtc-tps65910.o
 obj-$(CONFIG_RTC_DRV_TX4939)	+= rtc-tx4939.o
 obj-$(CONFIG_RTC_DRV_V3020)	+= rtc-v3020.o
 obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41xx.o
diff --git a/drivers/rtc/rtc-m41t80.c b/drivers/rtc/rtc-m41t80.c
index 64aedd8..e791f62 100644
--- a/drivers/rtc/rtc-m41t80.c
+++ b/drivers/rtc/rtc-m41t80.c
@@ -66,7 +66,8 @@
 #define M41T80_FEATURE_WD	(1 << 3)	/* Extra watchdog resolution */
 #define M41T80_FEATURE_SQ_ALT	(1 << 4)	/* RSx bits are in reg 4 */
 
-#define DRV_VERSION "0.05"
+#define DRV_NAME		"rtc-m41t80"
+#define DRV_VERSION		"0.05"
 
 static DEFINE_MUTEX(m41t80_rtc_mutex);
 static const struct i2c_device_id m41t80_id[] = {
@@ -80,6 +81,7 @@ static const struct i2c_device_id m41t80_id[] = {
 	{ "m41st84", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },
 	{ "m41st85", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },
 	{ "m41st87", M41T80_FEATURE_HT | M41T80_FEATURE_BL | M41T80_FEATURE_SQ },
+	{ "rv4162c7", M41T80_FEATURE_SQ | M41T80_FEATURE_SQ_ALT },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, m41t80_id);
@@ -354,22 +356,41 @@ static int m41t80_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *t)
 	return 0;
 }
 
+static irqreturn_t m41t80_rtc_interrupt(int irq, void *data)
+{
+	struct i2c_client *client = data;
+	struct m41t80_data *clientdata = i2c_get_clientdata(client);
+	u8 wbuf[M41T80_ALARM_REG_SIZE];
+	u8 *reg = wbuf - M41T80_REG_ALARM_MON;
+
+	/* disable alarm */
+	if (i2c_smbus_read_i2c_block_data(client, M41T80_REG_ALARM_MON,
+			M41T80_ALARM_REG_SIZE, wbuf) < 0)
+		dev_err(&client->dev, "read error\n");
+
+	reg[M41T80_REG_ALARM_MON] &= ~0xbf;
+	reg[M41T80_REG_ALARM_DAY] = 0;
+	reg[M41T80_REG_ALARM_HOUR] = 0;
+	reg[M41T80_REG_ALARM_MIN] = 0;
+	reg[M41T80_REG_ALARM_SEC] = 0;
+
+	if (i2c_smbus_write_i2c_block_data(client, M41T80_REG_ALARM_MON,
+				M41T80_ALARM_REG_SIZE, wbuf) < 0)
+		dev_err(&client->dev, "write error\n");
+
+	/* clear interrupt with reading the flag register*/
+	if (i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS) < 0)
+		dev_err(&client->dev, "read error\n");
+
+	rtc_update_irq(clientdata->rtc, 1, RTC_IRQF | RTC_AF);
+
+	return IRQ_HANDLED;
+}
+
 static struct rtc_class_ops m41t80_rtc_ops = {
 	.read_time = m41t80_rtc_read_time,
 	.set_time = m41t80_rtc_set_time,
-	/*
-	 * XXX - m41t80 alarm functionality is reported broken.
-	 * until it is fixed, don't register alarm functions.
-	 *
-	.read_alarm = m41t80_rtc_read_alarm,
-	.set_alarm = m41t80_rtc_set_alarm,
-	*/
 	.proc = m41t80_rtc_proc,
-	/*
-	 * See above comment on broken alarm
-	 *
-	.alarm_irq_enable = m41t80_rtc_alarm_irq_enable,
-	*/
 };
 
 #if defined(CONFIG_RTC_INTF_SYSFS) || defined(CONFIG_RTC_INTF_SYSFS_MODULE)
@@ -795,6 +816,22 @@ static int m41t80_probe(struct i2c_client *client,
 	clientdata->features = id->driver_data;
 	i2c_set_clientdata(client, clientdata);
 
+	if (client->irq > 0) {
+		rc = request_threaded_irq(client->irq, NULL,
+				m41t80_rtc_interrupt,
+				IRQF_TRIGGER_FALLING,
+				DRV_NAME, client);
+
+		if (!rc) {
+			m41t80_rtc_ops.read_alarm = m41t80_rtc_read_alarm;
+			m41t80_rtc_ops.set_alarm = m41t80_rtc_set_alarm;
+			m41t80_rtc_ops.alarm_irq_enable =
+						m41t80_rtc_alarm_irq_enable;
+		} else {
+			dev_err(&client->dev, "Failed to request RTC IRQ\n");
+		}
+	}
+
 	rtc = rtc_device_register(client->name, &client->dev,
 				  &m41t80_rtc_ops, THIS_MODULE);
 	if (IS_ERR(rtc)) {
@@ -842,6 +879,7 @@ static int m41t80_probe(struct i2c_client *client,
 	if (rc)
 		goto exit;
 
+
 #ifdef CONFIG_RTC_DRV_M41T80_WDT
 	if (clientdata->features & M41T80_FEATURE_HT) {
 		save_client = client;
@@ -884,6 +922,8 @@ static int m41t80_remove(struct i2c_client *client)
 		unregister_reboot_notifier(&wdt_notifier);
 	}
 #endif
+	free_irq(client->irq, client);
+
 	if (rtc)
 		rtc_device_unregister(rtc);
 	kfree(clientdata);
@@ -893,7 +933,7 @@ static int m41t80_remove(struct i2c_client *client)
 
 static struct i2c_driver m41t80_driver = {
 	.driver = {
-		.name = "rtc-m41t80",
+		.name = DRV_NAME,
 	},
 	.probe = m41t80_probe,
 	.remove = m41t80_remove,
diff --git a/drivers/rtc/rtc-tps65910.c b/drivers/rtc/rtc-tps65910.c
new file mode 100644
index 0000000..50e3b1b
--- /dev/null
+++ b/drivers/rtc/rtc-tps65910.c
@@ -0,0 +1,538 @@
+/*
+ * rtc-tps85910.c -- TPS65910 Real Time Clock interface
+ *
+ * Copyright (C) 2012 Phytec
+ *
+ * Based on original TI driver twl-rtc.c
+ * Copyright (C) 2007 MontaVista Software, Inc
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+
+#include <linux/i2c/twl.h>
+#include <linux/mfd/tps65910.h>
+
+
+/*
+ * RTC block register offsets (use TWL_MODULE_RTC)
+ */
+enum {
+	REG_SECONDS_REG = 0,
+	REG_MINUTES_REG,
+	REG_HOURS_REG,
+	REG_DAYS_REG,
+	REG_MONTHS_REG,
+	REG_YEARS_REG,
+	REG_WEEKS_REG,
+
+	REG_ALARM_SECONDS_REG,
+	REG_ALARM_MINUTES_REG,
+	REG_ALARM_HOURS_REG,
+	REG_ALARM_DAYS_REG,
+	REG_ALARM_MONTHS_REG,
+	REG_ALARM_YEARS_REG,
+
+	REG_RTC_CTRL_REG,
+	REG_RTC_STATUS_REG,
+	REG_RTC_INTERRUPTS_REG,
+
+	REG_RTC_COMP_LSB_REG,
+	REG_RTC_COMP_MSB_REG,
+};
+static const u8 rtc_reg_map[] = {
+	[REG_SECONDS_REG] = 0x00,
+	[REG_MINUTES_REG] = 0x01,
+	[REG_HOURS_REG] = 0x02,
+	[REG_DAYS_REG] = 0x03,
+	[REG_MONTHS_REG] = 0x04,
+	[REG_YEARS_REG] = 0x05,
+	[REG_WEEKS_REG] = 0x06,
+
+	[REG_ALARM_SECONDS_REG] = 0x08,
+	[REG_ALARM_MINUTES_REG] = 0x09,
+	[REG_ALARM_HOURS_REG] = 0x0A,
+	[REG_ALARM_DAYS_REG] = 0x0B,
+	[REG_ALARM_MONTHS_REG] = 0x0C,
+	[REG_ALARM_YEARS_REG] = 0x0D,
+
+	[REG_RTC_CTRL_REG] = 0x10,
+	[REG_RTC_STATUS_REG] = 0x11,
+	[REG_RTC_INTERRUPTS_REG] = 0x12,
+
+	[REG_RTC_COMP_LSB_REG] = 0x13,
+	[REG_RTC_COMP_MSB_REG] = 0x14,
+};
+
+/* RTC_CTRL_REG bitfields */
+#define BIT_RTC_CTRL_REG_STOP_RTC_M              0x01
+#define BIT_RTC_CTRL_REG_ROUND_30S_M             0x02
+#define BIT_RTC_CTRL_REG_AUTO_COMP_M             0x04
+#define BIT_RTC_CTRL_REG_MODE_12_24_M            0x08
+#define BIT_RTC_CTRL_REG_TEST_MODE_M             0x10
+#define BIT_RTC_CTRL_REG_SET_32_COUNTER_M        0x20
+#define BIT_RTC_CTRL_REG_GET_TIME_M              0x40
+
+/* RTC_STATUS_REG bitfields */
+#define BIT_RTC_STATUS_REG_RUN_M                 0x02
+#define BIT_RTC_STATUS_REG_1S_EVENT_M            0x04
+#define BIT_RTC_STATUS_REG_1M_EVENT_M            0x08
+#define BIT_RTC_STATUS_REG_1H_EVENT_M            0x10
+#define BIT_RTC_STATUS_REG_1D_EVENT_M            0x20
+#define BIT_RTC_STATUS_REG_ALARM_M               0x40
+#define BIT_RTC_STATUS_REG_POWER_UP_M            0x80
+
+/* RTC_INTERRUPTS_REG bitfields */
+#define BIT_RTC_INTERRUPTS_REG_EVERY_M           0x03
+#define BIT_RTC_INTERRUPTS_REG_IT_TIMER_M        0x04
+#define BIT_RTC_INTERRUPTS_REG_IT_ALARM_M        0x08
+
+
+/* REG_SECONDS_REG through REG_YEARS_REG is how many registers? */
+#define ALL_TIME_REGS		7
+#define ALL_ALARM_REGS		6
+
+struct tps65910 *tps65910;
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Supports 1 byte read from RTC register.
+ */
+static int tps_rtc_read(u8 *data, u8 reg, int len)
+{
+	int ret;
+
+	if (!tps65910 || !tps65910->read)
+		return -ENODEV;
+
+	ret = tps65910->read(tps65910, (rtc_reg_map[reg]), len, data);
+	if (ret < 0)
+		pr_err("tps65910_rtc: Could not read "
+			"register %X - error %d\n", reg, ret);
+	return ret;
+}
+
+/*
+ * Supports 1 byte write to RTC registers.
+ */
+static int tps_rtc_write(u8 *data, u8 reg, int len)
+{
+	int ret;
+
+	if (!tps65910 || !tps65910->write)
+		return -ENODEV;
+
+	ret = tps65910->write(tps65910, (rtc_reg_map[reg]), len, data);
+	if (ret < 0)
+		pr_err("tps65910_rtc: Could not write "
+		       "register %X - error %d\n", reg, ret);
+	return ret;
+}
+
+/*
+ * Cache the value for timer/alarm interrupts register; this is
+ * only changed by callers holding rtc ops lock (or resume).
+ */
+static unsigned char rtc_irq_bits = 0;
+
+/*
+ * Enable 1/second update and/or alarm interrupts.
+ */
+static int set_rtc_irq_bit(unsigned char bit)
+{
+	unsigned char val;
+	int ret;
+
+	val = rtc_irq_bits | bit;
+	val &= ~BIT_RTC_INTERRUPTS_REG_EVERY_M;
+	ret = tps_rtc_write(&val, REG_RTC_INTERRUPTS_REG, 1);
+	if (ret == 0)
+		rtc_irq_bits = val;
+
+	return ret;
+}
+
+/*
+ * Disable update and/or alarm interrupts.
+ */
+static int mask_rtc_irq_bit(unsigned char bit)
+{
+	unsigned char val;
+	int ret;
+
+	val = rtc_irq_bits & ~bit;
+	ret = tps_rtc_write(&val, REG_RTC_INTERRUPTS_REG, 1);
+	if (ret == 0)
+		rtc_irq_bits = val;
+
+	return ret;
+}
+
+static int tps_rtc_alarm_irq_enable(struct device *dev, unsigned enabled)
+{
+	int ret;
+
+	if (enabled)
+		ret = set_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
+	else
+		ret = mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
+
+	return ret;
+}
+
+/*
+ * Gets current RTC time and date parameters.
+ *
+ * The RTC's time/alarm representation is not what gmtime(3) requires
+ * Linux to use:
+ *
+ *  - Months are 1..12 vs Linux 0-11
+ *  - Years are 0..99 vs Linux 1900..N (we assume 21st century)
+ */
+static int tps_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned char rtc_data[ALL_TIME_REGS];
+	int ret;
+	u8 save_control;
+
+	ret = tps_rtc_read(&save_control, REG_RTC_CTRL_REG, 1);
+	if (ret < 0)
+		return ret;
+
+	save_control |= BIT_RTC_CTRL_REG_GET_TIME_M;
+
+	ret = tps_rtc_write(&save_control, REG_RTC_CTRL_REG, 1);
+	if (ret < 0)
+		return ret;
+
+	ret = tps_rtc_read(rtc_data, REG_SECONDS_REG, ALL_TIME_REGS);
+
+	if (ret >= 0) {
+		tm->tm_sec = bcd2bin(rtc_data[0]);
+		tm->tm_min = bcd2bin(rtc_data[1]);
+		tm->tm_hour = bcd2bin(rtc_data[2]);
+		tm->tm_mday = bcd2bin(rtc_data[3]);
+		tm->tm_mon = bcd2bin(rtc_data[4]) - 1;
+		tm->tm_year = bcd2bin(rtc_data[5]) + 100;
+	}
+
+	return ret;
+}
+
+static int tps_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned char save_control;
+	unsigned char rtc_data[ALL_TIME_REGS];
+	int ret;
+
+	rtc_data[0] = bin2bcd(tm->tm_sec);
+	rtc_data[1] = bin2bcd(tm->tm_min);
+	rtc_data[2] = bin2bcd(tm->tm_hour);
+	rtc_data[3] = bin2bcd(tm->tm_mday);
+	rtc_data[4] = bin2bcd(tm->tm_mon + 1);
+	rtc_data[5] = bin2bcd(tm->tm_year - 100);
+	rtc_data[6] = bin2bcd(tm->tm_wday);
+
+	/* Stop RTC while updating the TC registers */
+	ret = tps_rtc_read(&save_control, REG_RTC_CTRL_REG, 1);
+	if (ret < 0)
+		goto out;
+
+	save_control &= ~BIT_RTC_CTRL_REG_STOP_RTC_M;
+	ret = tps_rtc_write(&save_control, REG_RTC_CTRL_REG, 1);
+	if (ret < 0)
+		goto out;
+
+	/* update all the time registers in one shot */
+	ret = tps_rtc_write(rtc_data, REG_SECONDS_REG, ALL_TIME_REGS);
+	if (ret < 0)
+		goto out;
+
+	/* Start back RTC */
+	save_control |= BIT_RTC_CTRL_REG_STOP_RTC_M;
+	ret = tps_rtc_write(&save_control, REG_RTC_CTRL_REG, 1);
+
+out:
+	return ret;
+}
+
+/*
+ * Gets current RTC alarm time.
+ */
+static int tps_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	unsigned char rtc_data[ALL_ALARM_REGS];
+	int ret;
+
+	ret = tps_rtc_read(rtc_data, REG_ALARM_SECONDS_REG, ALL_TIME_REGS);
+	if (ret < 0)
+		return ret;
+
+	/* some of these fields may be wildcard/"match all" */
+	alm->time.tm_sec = bcd2bin(rtc_data[0]);
+	alm->time.tm_min = bcd2bin(rtc_data[1]);
+	alm->time.tm_hour = bcd2bin(rtc_data[2]);
+	alm->time.tm_mday = bcd2bin(rtc_data[3]);
+	/* Month register ranges from 1-12, need tm_mon from 0 to 11 */
+	alm->time.tm_mon = bcd2bin(rtc_data[4]) - 1;
+	alm->time.tm_year = bcd2bin(rtc_data[5]) + 100;
+
+	/* report cached alarm enable state */
+	if (rtc_irq_bits & BIT_RTC_INTERRUPTS_REG_IT_ALARM_M)
+		alm->enabled = 1;
+
+	return ret;
+}
+
+static int tps_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	unsigned char alarm_data[ALL_ALARM_REGS];
+	int ret;
+
+	ret = tps_rtc_alarm_irq_enable(dev, 0);
+	if (ret)
+		goto out;
+
+	alarm_data[0] = bin2bcd(alm->time.tm_sec);
+	alarm_data[1] = bin2bcd(alm->time.tm_min);
+	alarm_data[2] = bin2bcd(alm->time.tm_hour);
+	alarm_data[3] = bin2bcd(alm->time.tm_mday);
+	alarm_data[4] = bin2bcd(alm->time.tm_mon + 1);
+	alarm_data[5] = bin2bcd(alm->time.tm_year - 100);
+
+	/* update all the alarm registers in one shot */
+	ret = tps_rtc_write(alarm_data, REG_ALARM_SECONDS_REG, ALL_ALARM_REGS);
+	if (!ret && alm->enabled)
+		ret = tps_rtc_alarm_irq_enable(dev, 1);
+out:
+	return ret;
+}
+
+static irqreturn_t tps_rtc_interrupt(int irq, void *rtc)
+{
+	unsigned long events = 0;
+	int ret = IRQ_NONE;
+	int res;
+	u8 rd_reg, rd_reg_mod;
+
+	res = tps_rtc_read(&rd_reg, REG_RTC_STATUS_REG, 1);
+	if (res)
+		goto out;
+	/*
+	 * Figure out source of interrupt: ALARM or TIMER in RTC_STATUS_REG.
+	 * only one (ALARM or RTC) interrupt source may be enabled
+	 * at time, we also could check our results
+	 * by reading RTS_INTERRUPTS_REGISTER[IT_TIMER,IT_ALARM]
+	 */
+	if (rd_reg & BIT_RTC_STATUS_REG_ALARM_M)
+		events |= RTC_IRQF | RTC_AF;
+	else
+		events |= RTC_IRQF | RTC_UF;
+
+	rd_reg_mod = rd_reg | BIT_RTC_STATUS_REG_ALARM_M;
+	res = tps_rtc_write(&rd_reg_mod, REG_RTC_STATUS_REG, 1);
+	if (res)
+		goto out;
+
+	/* Clear on Read enabled. RTC_IT bit of TWL4030_INT_PWR_ISR1
+	 * needs 2 reads to clear the interrupt. One read is done in
+	 * do_tps_pwrirq(). Doing the second read, to clear
+	 * the bit.
+	 *
+	 * FIXME the reason PWR_ISR1 needs an extra read is that
+	 * RTC_IF retriggered until we cleared REG_ALARM_M above.
+	 * But re-reading like this is a bad hack; by doing so we
+	 * risk wrongly clearing status for some other IRQ (losing
+	 * the interrupt).  Be smarter about handling RTC_UF ...
+	 */
+	res = tps_rtc_read(&rd_reg, TWL4030_INT_PWR_ISR1, 1);
+	if (res)
+		goto out;
+
+	/* Notify RTC core on event */
+	rtc_update_irq(rtc, 1, events);
+
+	ret = IRQ_HANDLED;
+out:
+	return ret;
+}
+
+static struct rtc_class_ops tps_rtc_ops = {
+	.read_time	= tps_rtc_read_time,
+	.set_time	= tps_rtc_set_time,
+	.read_alarm	= tps_rtc_read_alarm,
+	.set_alarm	= tps_rtc_set_alarm,
+	.alarm_irq_enable = tps_rtc_alarm_irq_enable,
+};
+
+/*----------------------------------------------------------------------*/
+
+static int __devinit tps_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	int ret = -EINVAL;
+	int irq = platform_get_irq(pdev, 0);
+	u8 rd_reg;
+
+	/*
+	 * Currently handle just one tps65910 device.  Unfortunately,
+	 * there is no where to keep track of the parent in
+	 * struct rtc_device to handle more than one.
+	 */
+	tps65910 = dev_get_drvdata(pdev->dev.parent);
+
+	if (irq <= 0)
+		goto out1;
+
+	ret = tps_rtc_read(&rd_reg, REG_RTC_STATUS_REG, 1);
+	if (ret < 0)
+		goto out1;
+
+	if (rd_reg & BIT_RTC_STATUS_REG_POWER_UP_M)
+		dev_warn(&pdev->dev, "Power up reset detected.\n");
+
+	if (rd_reg & BIT_RTC_STATUS_REG_ALARM_M)
+		dev_warn(&pdev->dev, "Pending Alarm interrupt detected.\n");
+
+	/* Clear RTC Power up reset and pending alarm interrupts */
+	ret = tps_rtc_write(&rd_reg, REG_RTC_STATUS_REG, 1);
+	if (ret < 0)
+		goto out1;
+
+	/* Check RTC module status, Enable if it is off */
+	ret = tps_rtc_read(&rd_reg, REG_RTC_CTRL_REG, 1);
+	if (ret < 0)
+		goto out1;
+
+	if (!(rd_reg & BIT_RTC_CTRL_REG_STOP_RTC_M)) {
+		dev_info(&pdev->dev, "Enabling TWL-RTC.\n");
+		rd_reg = BIT_RTC_CTRL_REG_STOP_RTC_M;
+		ret = tps_rtc_write(&rd_reg, REG_RTC_CTRL_REG, 1);
+		if (ret < 0)
+			goto out1;
+	}
+
+	ret = tps_rtc_write(&rtc_irq_bits, REG_RTC_INTERRUPTS_REG, 1);
+	if (ret < 0)
+		goto out1;
+
+	rtc = rtc_device_register(pdev->name,
+				  &pdev->dev, &tps_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		ret = PTR_ERR(rtc);
+		dev_err(&pdev->dev, "can't register RTC device, err %ld\n",
+			PTR_ERR(rtc));
+		goto out1;
+	}
+
+	if (irq > 0) {
+		ret = request_threaded_irq(irq, NULL, tps_rtc_interrupt,
+					IRQF_TRIGGER_RISING,
+					dev_name(&rtc->dev), rtc);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "IRQ is not free.\n");
+			goto out2;
+		}
+	}
+
+	platform_set_drvdata(pdev, rtc);
+	return 0;
+
+out2:
+	rtc_device_unregister(rtc);
+out1:
+	return ret;
+}
+
+/*
+ * Disable all RTC module interrupts.
+ * Sets status flag to free.
+ */
+static int __devexit tps_rtc_remove(struct platform_device *pdev)
+{
+	/* leave rtc running, but disable irqs */
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+	int irq = platform_get_irq(pdev, 0);
+
+	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
+	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
+
+	free_irq(irq, rtc);
+
+	rtc_device_unregister(rtc);
+	platform_set_drvdata(pdev, NULL);
+	tps65910 = NULL;
+	return 0;
+}
+
+static void tps_rtc_shutdown(struct platform_device *pdev)
+{
+	/* mask timer interrupts, but leave alarm interrupts on to enable
+	   power-on when alarm is triggered */
+	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
+}
+
+#ifdef CONFIG_PM
+
+static unsigned char irqstat;
+
+static int tps_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	irqstat = rtc_irq_bits;
+
+	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
+	return 0;
+}
+
+static int tps_rtc_resume(struct platform_device *pdev)
+{
+	set_rtc_irq_bit(irqstat);
+	return 0;
+}
+
+#else
+#define tps_rtc_suspend NULL
+#define tps_rtc_resume  NULL
+#endif
+
+MODULE_ALIAS("platform:tps65910-rtc");
+
+static struct platform_driver tps65910rtc_driver = {
+	.probe		= tps_rtc_probe,
+	.remove		= __devexit_p(tps_rtc_remove),
+	.shutdown	= tps_rtc_shutdown,
+	.suspend	= tps_rtc_suspend,
+	.resume		= tps_rtc_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "tps65910-rtc",
+	},
+};
+
+static int __init tps_rtc_init(void)
+{
+	return platform_driver_register(&tps65910rtc_driver);
+}
+module_init(tps_rtc_init);
+
+static void __exit tps_rtc_exit(void)
+{
+	platform_driver_unregister(&tps65910rtc_driver);
+}
+module_exit(tps_rtc_exit);
+
+MODULE_AUTHOR("Texas Instruments, MontaVista Software, Phytec");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index fc2d66f..ad825fb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -38,8 +38,6 @@
 
 static int debug;
 
-#define PL2303_CLOSING_WAIT	(30*HZ)
-
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
@@ -421,7 +419,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	control = priv->line_control;
 	if ((cflag & CBAUD) == B0)
 		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
-	else
+	else if ((old_termios->c_cflag & CBAUD) == B0)
 		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
 	if (control != priv->line_control) {
 		control = priv->line_control;
@@ -502,21 +500,20 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	if (tty)
 		pl2303_set_termios(tty, port, &tmp_termios);
 
-	dbg("%s - submitting read urb", __func__);
-	result = usb_serial_generic_submit_read_urb(port, GFP_KERNEL);
-	if (result) {
-		pl2303_close(port);
-		return -EPROTO;
-	}
-
 	dbg("%s - submitting interrupt urb", __func__);
 	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
 			" error %d\n", __func__, result);
-		pl2303_close(port);
-		return -EPROTO;
+		return result;
+	}
+
+	result = usb_serial_generic_open(tty, port);
+	if (result) {
+		usb_kill_urb(port->interrupt_in_urb);
+		return result;
 	}
+
 	port->port.drain_delay = 256;
 	return 0;
 }
@@ -525,12 +522,11 @@ static int pl2303_tiocmset(struct tty_struct *tty,
 			   unsigned int set, unsigned int clear)
 {
 	struct usb_serial_port *port = tty->driver_data;
+	struct usb_serial *serial = port->serial;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	u8 control;
-
-	if (!usb_get_intfdata(port->serial->interface))
-		return -ENODEV;
+	int ret;
 
 	spin_lock_irqsave(&priv->lock, flags);
 	if (set & TIOCM_RTS)
@@ -544,7 +540,14 @@ static int pl2303_tiocmset(struct tty_struct *tty,
 	control = priv->line_control;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	return set_control_lines(port->serial->dev, control);
+	mutex_lock(&serial->disc_mutex);
+	if (!serial->disconnected)
+		ret = set_control_lines(serial->dev, control);
+	else
+		ret = -ENODEV;
+	mutex_unlock(&serial->disc_mutex);
+
+	return ret;
 }
 
 static int pl2303_tiocmget(struct tty_struct *tty)
@@ -558,9 +561,6 @@ static int pl2303_tiocmget(struct tty_struct *tty)
 
 	dbg("%s (%d)", __func__, port->number);
 
-	if (!usb_get_intfdata(port->serial->interface))
-		return -ENODEV;
-
 	spin_lock_irqsave(&priv->lock, flags);
 	mcr = priv->line_control;
 	status = priv->line_status;
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index f66bf0e..d770174 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2240,7 +2240,7 @@ config FB_DA8XX
 
 config FB_DA8XX_CONSISTENT_DMA_SIZE
 	int "Consistent DMA memory size (MB)"
-	depends on (FB_DA8XX && MACH_AM335XEVM)
+	depends on FB_DA8XX && (MACH_PCM051 || MACH_AM335XEVM || MACH_PCAAXS1 || MACH_PFLA03)
 	range 1 14
 	default 4
 	help
diff --git a/drivers/video/da8xx-fb.c b/drivers/video/da8xx-fb.c
index 0d212dc..673b2bd2 100644
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@ -141,6 +141,7 @@ static resource_size_t da8xx_fb_reg_base;
 static struct resource *lcdc_regs;
 static unsigned int lcd_revision;
 static irq_handler_t lcdc_irq_handler;
+static char *panel_name;
 
 static inline unsigned int lcdc_read(unsigned int addr)
 {
@@ -290,6 +291,76 @@ static struct da8xx_panel known_lcd_panels[] = {
 		.pxl_clk = 9000000,
 		.invert_pxl_clk = 0,
 	},
+	/* Emerging ETM0700G0DH6 */
+	[4] = {
+		.name = "ETM0700G0DH6",
+		.width = 800,
+		.height = 480,
+		.hfp = 40,
+		.hbp = 216,
+		.hsw = 128,
+		.vfp = 10,
+		.vbp = 35,
+		.vsw = 2,
+		.pxl_clk = 40000000,
+		.invert_pxl_clk = 1,
+	},
+	/* Prime-View PM070WL4 */
+	[5] = {
+		.name = "PV_PM070WL4",
+		.width = 800,
+		.height = 480,
+		.hfp = 42,
+		.hbp = 86,
+		.hsw = 128,
+		.vfp = 10,
+		.vbp = 33,
+		.vsw = 2,
+		.pxl_clk = 32000000,
+		.invert_pxl_clk = 1,
+	},
+	/* Prime-View PD050VL1 */
+	[6] = {
+		.name = "PV_PD050VL1",
+		.width = 640,
+		.height = 480,
+		.hfp = 18,
+		.hbp = 46,
+		.hsw = 96,
+		.vfp = 10,
+		.vbp = 33,
+		.vsw = 2,
+		.pxl_clk = 25000000,
+		.invert_pxl_clk = 1,
+	},
+	/* Prime-View PD035VL1 */
+	[7] = {
+		.name = "PV_PD035VL1",
+		.width = 640,
+		.height = 480,
+		.hfp = 18,
+		.hbp = 46,
+		.hsw = 96,
+		.vfp = 10,
+		.vbp = 33,
+		.vsw = 2,
+		.pxl_clk = 25000000,
+		.invert_pxl_clk = 1,
+	},
+	/* Prime-View PD104SLF */
+	[8] = {
+		.name = "PV_PD104SLF",
+		.width = 800,
+		.height = 600,
+		.hfp = 42,
+		.hbp = 86,
+		.hsw = 128,
+		.vfp = 1,
+		.vbp = 23,
+		.vsw = 4,
+		.pxl_clk = 40000000,
+		.invert_pxl_clk = 1,
+	},
 };
 
 static inline bool is_raster_enabled(void)
@@ -768,6 +839,7 @@ static int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,
 
 
 	if ((QVGA != cfg->p_disp_panel->panel_type) &&
+			(VGA != cfg->p_disp_panel->panel_type) &&
 			(WVGA != cfg->p_disp_panel->panel_type))
 		return -EINVAL;
 
@@ -1332,18 +1404,21 @@ static unsigned int da8xxfb_pixel_clk_period(struct da8xx_fb_par *par)
 
 static int __devinit fb_probe(struct platform_device *device)
 {
-	struct da8xx_lcdc_platform_data *fb_pdata =
+	struct da8xx_lcdc_selection_platform_data *selection_fb_pdata =
 						device->dev.platform_data;
+	struct da8xx_lcdc_platform_data *fb_pdata = NULL;
 	struct lcd_ctrl_config *lcd_cfg;
-	struct da8xx_panel *lcdc_info;
+	struct da8xx_panel *lcdc_info = NULL;
 	struct fb_info *da8xx_fb_info;
 	struct clk *fb_clk = NULL;
 	struct da8xx_fb_par *par;
 	resource_size_t len;
-	int ret, i;
+	int ret, i, j;
 	unsigned long ulcm;
+	struct da8xx_panel *search_panels;
+	int num_search_panels;
 
-	if (fb_pdata == NULL) {
+	if (selection_fb_pdata == NULL) {
 		dev_err(&device->dev, "Can not get platform data\n");
 		return -ENOENT;
 	}
@@ -1396,14 +1471,41 @@ static int __devinit fb_probe(struct platform_device *device)
 		break;
 	}
 
-	for (i = 0, lcdc_info = known_lcd_panels;
-		i < ARRAY_SIZE(known_lcd_panels);
-		i++, lcdc_info++) {
-		if (strcmp(fb_pdata->type, lcdc_info->name) == 0)
-			break;
+	if (panel_name) {
+		/* check if the specified panel is unknown */
+		for (i = 0; i < ARRAY_SIZE(known_lcd_panels); i++) {
+			if (strcmp(panel_name, known_lcd_panels[i].name) == 0) {
+				search_panels = known_lcd_panels + i;
+				num_search_panels = 1;
+				break;
+			}
+		}
+
+		/* the panel is unknown here, return error */
+		if (i == ARRAY_SIZE(known_lcd_panels)) {
+			dev_err(&device->dev, "GLCD: No valid panel found\n");
+			ret = -ENODEV;
+			goto err_pm_runtime_disable;
+		}
+	} else {
+		/* the panel was not specified at boot, search all */
+		search_panels = known_lcd_panels;
+		num_search_panels = ARRAY_SIZE(known_lcd_panels);
+	}
+
+	for (i = 0; i < num_search_panels; i++) {
+		for (j = 0; j < selection_fb_pdata->entries_cnt; j++) {
+			if (strcmp(selection_fb_pdata->entries_ptr[j].type,
+					search_panels[i].name) == 0) {
+				fb_pdata = selection_fb_pdata->entries_ptr + j;
+				lcdc_info = search_panels + i;
+				goto lcdc_search_end;
+			}
+		}
 	}
 
-	if (i == ARRAY_SIZE(known_lcd_panels)) {
+lcdc_search_end:
+	if (i == num_search_panels) {
 		dev_err(&device->dev, "GLCD: No valid panel found\n");
 		ret = -ENODEV;
 		goto err_pm_runtime_disable;
@@ -1746,3 +1848,6 @@ module_exit(da8xx_fb_cleanup);
 MODULE_DESCRIPTION("Framebuffer driver for TI da8xx/omap-l1xx");
 MODULE_AUTHOR("Texas Instruments");
 MODULE_LICENSE("GPL");
+
+module_param(panel_name, charp, 0);
+MODULE_PARM_DESC(panel_name, "Specify which panel to use");
diff --git a/include/linux/input/edt-ft5x06.h b/include/linux/input/edt-ft5x06.h
new file mode 100644
index 0000000..8a1e0d1
--- /dev/null
+++ b/include/linux/input/edt-ft5x06.h
@@ -0,0 +1,24 @@
+#ifndef _EDT_FT5X06_H
+#define _EDT_FT5X06_H
+
+/*
+ * Copyright (c) 2012 Simon Budig, <simon.budig@kernelconcepts.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+struct edt_ft5x06_platform_data {
+	int irq_pin;
+	int reset_pin;
+
+	/* startup defaults for operational parameters */
+	bool use_parameters;
+	u8 gain;
+	u8 threshold;
+	u8 offset;
+	u8 report_rate;
+};
+
+#endif /* _EDT_FT5X06_H */
diff --git a/include/linux/micrel_phy.h b/include/linux/micrel_phy.h
index dd8da34..13a0dca 100644
--- a/include/linux/micrel_phy.h
+++ b/include/linux/micrel_phy.h
@@ -4,6 +4,7 @@
 #define MICREL_PHY_ID_MASK	0x00fffff0
 
 #define PHY_ID_KSZ9021		0x00221611
+#define PHY_ID_KSZ9031		0x00221620
 #define PHY_ID_KS8737		0x00221720
 #define PHY_ID_KS8041		0x00221510
 #define PHY_ID_KS8051		0x00221550
diff --git a/include/video/da8xx-fb.h b/include/video/da8xx-fb.h
index b188924..00cf615 100644
--- a/include/video/da8xx-fb.h
+++ b/include/video/da8xx-fb.h
@@ -14,6 +14,7 @@
 
 enum panel_type {
 	QVGA = 0,
+	VGA,
 	WVGA,
 };
 
@@ -43,6 +44,11 @@ struct da8xx_lcdc_platform_data {
 	int  (*get_context_loss_count)(struct device *);
 };
 
+struct da8xx_lcdc_selection_platform_data {
+	struct da8xx_lcdc_platform_data *entries_ptr;
+	int entries_cnt;
+};
+
 struct lcd_ctrl_config {
 	const struct display_panel *p_disp_panel;
 
diff --git a/net/ipv4/ipconfig.c b/net/ipv4/ipconfig.c
index 24e27c0..9103481 100644
--- a/net/ipv4/ipconfig.c
+++ b/net/ipv4/ipconfig.c
@@ -89,7 +89,7 @@
 
 /* Define the friendly delay before and after opening net devices */
 #define CONF_POST_OPEN		10	/* After opening: 10 msecs */
-#define CONF_CARRIER_TIMEOUT	120000	/* Wait for carrier timeout */
+#define CONF_CARRIER_TIMEOUT	1000	/* Wait for carrier timeout */
 
 /* Define the timeout for waiting for a DHCP/BOOTP/RARP reply */
 #define CONF_OPEN_RETRIES 	2	/* (Re)open devices twice */
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2bd594e..cee6c0ae 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -815,6 +815,7 @@ static const char *section_white_list[] =
 	".debug*",
 	".zdebug*",		/* Compressed debug sections. */
 	".GCC-command-line",	/* mn10300 */
+	".GCC.command.line",	/* record-gcc-switches, non mn10300 */
 	".mdebug*",        /* alpha, score, mips etc. */
 	".pdr",            /* alpha, score, mips etc. */
 	".stab*",
diff --git a/sound/soc/codecs/wm8974.c b/sound/soc/codecs/wm8974.c
index 9352f1e..e5b92a8 100644
--- a/sound/soc/codecs/wm8974.c
+++ b/sound/soc/codecs/wm8974.c
@@ -517,12 +517,12 @@ static int wm8974_mute(struct snd_soc_dai *dai, int mute)
 static int wm8974_set_bias_level(struct snd_soc_codec *codec,
 	enum snd_soc_bias_level level)
 {
-	u16 power1 = snd_soc_read(codec, WM8974_POWER1) & ~0x3;
+	u16 power1 = snd_soc_read(codec, WM8974_POWER1) & ~0x13;
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
 	case SND_SOC_BIAS_PREPARE:
-		power1 |= 0x1;  /* VMID 50k */
+		power1 |= 0x11;  /* VMID 50k */
 		snd_soc_write(codec, WM8974_POWER1, power1);
 		break;
 
diff --git a/sound/soc/davinci/Kconfig b/sound/soc/davinci/Kconfig
index 6b8dc37..9c3b609 100644
--- a/sound/soc/davinci/Kconfig
+++ b/sound/soc/davinci/Kconfig
@@ -100,3 +100,11 @@ config  SND_DA850_SOC_EVM
 	  Say Y if you want to add support for SoC audio on TI
 	  DA850/OMAP-L138 EVM
 
+config  SND_PCM051_SOC_BOARD
+	tristate "SoC Audio support for Phytec PCM051 development board"
+	depends on SND_AM33XX_SOC
+	select SND_DAVINCI_SOC_MCASP
+	select SND_SOC_WM8974
+	help
+	  Say Y if you want to add support for SoC audio on
+	  Phytec PCM051
diff --git a/sound/soc/davinci/Makefile b/sound/soc/davinci/Makefile
index a7af786..f9bdfa9 100644
--- a/sound/soc/davinci/Makefile
+++ b/sound/soc/davinci/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_SND_DAVINCI_SOC_VCIF) += snd-soc-davinci-vcif.o
 # DAVINCI Machine Support
 snd-soc-evm-objs := davinci-evm.o
 snd-soc-sffsdr-objs := davinci-sffsdr.o
+snd-soc-pcm051-objs := davinci-pcm051.o
 
 obj-$(CONFIG_SND_DAVINCI_SOC_EVM) += snd-soc-evm.o
 obj-$(CONFIG_SND_DM6467_SOC_EVM) += snd-soc-evm.o
@@ -20,3 +21,4 @@ obj-$(CONFIG_SND_DA830_SOC_EVM) += snd-soc-evm.o
 obj-$(CONFIG_SND_DA850_SOC_EVM) += snd-soc-evm.o
 obj-$(CONFIG_SND_AM335X_SOC_EVM) += snd-soc-evm.o
 obj-$(CONFIG_SND_DAVINCI_SOC_SFFSDR) += snd-soc-sffsdr.o
+obj-$(CONFIG_SND_PCM051_SOC_BOARD) += snd-soc-pcm051.o
diff --git a/sound/soc/davinci/davinci-mcasp.c b/sound/soc/davinci/davinci-mcasp.c
index 62b95ce..f374095 100644
--- a/sound/soc/davinci/davinci-mcasp.c
+++ b/sound/soc/davinci/davinci-mcasp.c
@@ -339,6 +339,11 @@ static inline void mcasp_set_ctl_reg(void __iomem *regs, u32 val)
 
 static void mcasp_start_rx(struct davinci_audio_dev *dev)
 {
+	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);
+	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);
+
+	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);
+
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXCLKRST);
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSERCLR);
@@ -350,6 +355,8 @@ static void mcasp_start_rx(struct davinci_audio_dev *dev)
 
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);
+
+	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXBUF_REG, 0);
 }
 
 static void mcasp_start_tx(struct davinci_audio_dev *dev)
@@ -364,6 +371,7 @@ static void mcasp_start_tx(struct davinci_audio_dev *dev)
 
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXSMRST);
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);
+
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);
 	for (i = 0; i < dev->num_serializer; i++) {
 		if (dev->serial_dir[i] == TX_MODE) {
@@ -419,7 +427,9 @@ static void davinci_mcasp_start(struct davinci_audio_dev *dev, int stream)
 static void mcasp_stop_rx(struct davinci_audio_dev *dev)
 {
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, 0);
+	mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, 0);
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);
+	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);
 }
 
 static void mcasp_stop_tx(struct davinci_audio_dev *dev)
@@ -537,6 +547,8 @@ static int davinci_mcasp_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 		return -EINVAL;
 	}
 
+	dev->dai_fmt = fmt;
+
 	return 0;
 }
 
@@ -683,21 +695,33 @@ static void davinci_hw_common_param(struct davinci_audio_dev *dev, int stream)
 static void davinci_hw_param(struct davinci_audio_dev *dev, int stream)
 {
 	int i, active_slots;
-	u32 mask = 0;
+	u32 mask = 0, val;
 
 	active_slots = (dev->tdm_slots > 31) ? 32 : dev->tdm_slots;
 	for (i = 0; i < active_slots; i++)
 		mask |= (1 << i);
 
-	mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);
-
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		/* bit stream is MSB first  with no delay */
-		/* DSP_B mode */
+		/* bit stream is MSB first with no delay */
+		/* DSP_B mode or I2S mode */
+		/* AHCLK from internal clk */
 		mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
 				AHCLKXE);
+		/* in which tdm slots is the transmitter active */
 		mcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, mask);
-		mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXORD);
+
+		/* MSB first (and 1 bit delay for I2S) */
+		val = TXORD;
+		if ((dev->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+			SND_SOC_DAIFMT_I2S)
+			val |= FSXDLY(1);
+
+		mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, val);
+
+		if (((dev->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+				SND_SOC_DAIFMT_I2S) &&
+			(dev->tdm_slots != 2))
+			dev_err(dev->dev, "I2S should have 2 tdm_slots\n");
 
 		if ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))
 			mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
@@ -706,23 +730,53 @@ static void davinci_hw_param(struct davinci_audio_dev *dev, int stream)
 			printk(KERN_ERR "playback tdm slot %d not supported\n",
 				dev->tdm_slots);
 
-		mcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);
+		/* frame sync width */
+		if ((dev->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+				SND_SOC_DAIFMT_I2S)
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
+					FSXDUR);
+		else
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
+					FSXDUR);
 	} else {
-		/* bit stream is MSB first with no delay */
-		/* DSP_B mode */
-		mcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, RXORD);
+		/* bit stream is MSB first (and 1 bit delay for I2S) */
+		/* DSP_B mode or I2S mode */
+		val = TXORD;
+		if ((dev->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+				SND_SOC_DAIFMT_I2S)
+			val |= FSXDLY(1);
+		mcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, val);
+
+		mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
+				AHCLKXE);
 		mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,
 				AHCLKRE);
 		mcasp_set_reg(dev->base + DAVINCI_MCASP_RXTDM_REG, mask);
 
-		if ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))
+		if ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32)) {
 			mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG,
 					FSRMOD(dev->tdm_slots), FSRMOD(0x1FF));
+			mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
+					FSRMOD(dev->tdm_slots), FSXMOD(0x1FF));
+			}
 		else
 			printk(KERN_ERR "capture tdm slot %d not supported\n",
 				dev->tdm_slots);
 
-		mcasp_clr_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);
+		/* frame sync width */
+		if ((dev->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+				SND_SOC_DAIFMT_I2S) {
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
+				FSXDUR);
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG,
+				FSRDUR);
+			}
+		else {
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
+				FSXDUR);
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG,
+				FSRDUR);
+			}
 	}
 }
 
@@ -861,11 +915,80 @@ static int davinci_mcasp_startup(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static int davinci_mcasp_set_dai_clkdiv(struct snd_soc_dai *dai, int div_id,
+		int div)
+{
+	struct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	switch (div_id) {
+	case DAVINCI_MCASP_CLKXDIV:
+		div--;
+		if (div < 0) {
+			dev_err(dev->dev, "tried to set invalid clkdiv\n");
+			return -EINVAL;
+		} else if (div/3 > 31) {
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
+				AHCLKXDIV(0xfff));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
+				AHCLKXDIV(3));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,
+				ACLKXDIV(0x1F));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,
+				ACLKXDIV(div/4));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,
+				AHCLKRDIV(0xfff));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,
+				AHCLKRDIV(3));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKRCTL_REG,
+				ACLKRDIV(0x1F));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKRCTL_REG,
+				ACLKRDIV(div/4));
+		} else if (div > 31) {
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
+				AHCLKXDIV(0xfff));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
+				AHCLKXDIV(2));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,
+				ACLKXDIV(0x1F));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,
+				ACLKXDIV(div/3));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,
+				AHCLKRDIV(0xfff));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,
+				AHCLKRDIV(2));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKRCTL_REG,
+				ACLKRDIV(0x1F));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKRCTL_REG,
+				ACLKRDIV(div/3));
+		} else {
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
+				AHCLKXDIV(0xfff));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,
+				ACLKXDIV(0x1F));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,
+				ACLKXDIV(div));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,
+				AHCLKRDIV(0xfff));
+			mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKRCTL_REG,
+				ACLKRDIV(0x1F));
+			mcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKRCTL_REG,
+				ACLKRDIV(div));
+		}
+		break;
+	default:
+		dev_err(dev->dev, "tried to set unsupported clkdiv\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static struct snd_soc_dai_ops davinci_mcasp_dai_ops = {
 	.startup	= davinci_mcasp_startup,
 	.trigger	= davinci_mcasp_trigger,
 	.hw_params	= davinci_mcasp_hw_params,
 	.set_fmt	= davinci_mcasp_set_dai_fmt,
+	.set_clkdiv	= davinci_mcasp_set_dai_clkdiv,
 
 };
 
diff --git a/sound/soc/davinci/davinci-mcasp.h b/sound/soc/davinci/davinci-mcasp.h
index a42cc8c..4fb602d 100644
--- a/sound/soc/davinci/davinci-mcasp.h
+++ b/sound/soc/davinci/davinci-mcasp.h
@@ -26,6 +26,9 @@
 #define DAVINCI_MCASP_I2S_DAI	0
 #define DAVINCI_MCASP_DIT_DAI	1
 
+#define DAVINCI_MCASP_CLKXDIV   0
+#define DAVINCI_MCASP_HCLKXDIV  1
+
 enum {
 	DAVINCI_AUDIO_WORD_8 = 0,
 	DAVINCI_AUDIO_WORD_12,
@@ -44,6 +47,7 @@ struct davinci_audio_dev {
 	struct clk *clk;
 	unsigned int codec_fmt;
 	u8 clk_active;
+	int dai_fmt;
 
 	/* McASP specific data */
 	int	tdm_slots;
diff --git a/sound/soc/davinci/davinci-pcm051.c b/sound/soc/davinci/davinci-pcm051.c
new file mode 100644
index 0000000..9c8d597
--- /dev/null
+++ b/sound/soc/davinci/davinci-pcm051.c
@@ -0,0 +1,210 @@
+/*
+ * ASoC driver for phytec pcm051 development board (platform)
+ *
+ * Author:      Lars Poeschel <poeschel@lemonage.de>
+ * Copyright:   (C) 2012 Lemonage Software GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <asm/mach-types.h>
+
+#include <asm/hardware/asp.h>
+#include <mach/edma.h>
+#include <mach/board-pcm051.h>
+
+#include "davinci-pcm.h"
+#include "davinci-i2s.h"
+#include "davinci-mcasp.h"
+#include "../codecs/wm8974.h"
+
+#define AUDIO_FORMAT (SND_SOC_DAIFMT_I2S | \
+		SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_NB_NF)
+
+#define PCM051_AUXCLK (25000000)
+#define CODEC_CLOCK	12288000
+
+static int pcm051_hw_params(struct snd_pcm_substream *substream,
+			 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	unsigned int pll_out = 0;
+	int ret = 0;
+	int rate, div;
+
+	rate = params_rate(params);
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+		pll_out = 12288000;
+		break;
+	case 48000:
+		pll_out = 22579200;
+		break;
+	case 96000:
+		pll_out = 24576000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		pll_out = 22579200;
+		break;
+	default:
+		printk(KERN_ERR "audio clock is not matched pcm051 card\n");
+	}
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, AUDIO_FORMAT);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, AUDIO_FORMAT);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu CLKXDIV */
+	div = PCM051_AUXCLK / (rate * 16 * 2);
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, DAVINCI_MCASP_CLKXDIV,
+		PCM051_AUXCLK / (rate * 16 * 2));
+	if (ret < 0)
+		return ret;
+
+	if (div/3 > 31) {
+		ret = snd_soc_dai_set_pll(codec_dai, 0, 0, PCM051_AUXCLK/4,
+		pll_out);
+		if (ret < 0)
+			return ret;
+	} else if (div > 31) {
+		ret = snd_soc_dai_set_pll(codec_dai, 0, 0, PCM051_AUXCLK/3,
+		pll_out);
+		if (ret < 0)
+			return ret;
+	} else {
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, 0, PCM051_AUXCLK,
+		pll_out);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+static struct snd_soc_ops pcm051_ops = {
+	.hw_params = pcm051_hw_params,
+};
+
+/* phytec pcm051 machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8974_dapm_widgets[] = {
+	SND_SOC_DAPM_SPK("Loudspeaker", NULL),
+	SND_SOC_DAPM_LINE("Mono out", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+};
+
+/* davinci-pcm051 machine audio_map connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Loudspeaker connected to SPKOUTP, SPKOUTN */
+	{"Loudspeaker", NULL, "SPKOUTP"},
+	{"Loudspeaker", NULL, "SPKOUTN"},
+
+	/* Mono out connected to MONOOUT */
+	{"Mono out", NULL, "MONOOUT"},
+
+	/* Mic connected to MICN */
+	{"Mic Jack", NULL, "MICN"},
+};
+
+/* Logic for the wm8974 codec as connected on the phytec pcm051 */
+static int pcm051_wm8974_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	/* Add davinci-pcm051 specific widgets */
+	snd_soc_dapm_new_controls(dapm, wm8974_dapm_widgets,
+				  ARRAY_SIZE(wm8974_dapm_widgets));
+
+	/* Set up davinci-pcm051 specific audio path audio_map */
+	snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+
+	/* not connected */
+	snd_soc_dapm_disable_pin(dapm, "MICP");
+	snd_soc_dapm_disable_pin(dapm, "AUX");
+
+	/* always connected */
+	snd_soc_dapm_enable_pin(dapm, "Loudspeaker");
+	snd_soc_dapm_enable_pin(dapm, "Mono out");
+	snd_soc_dapm_enable_pin(dapm, "Mic Jack");
+
+	return 0;
+}
+
+static struct snd_soc_dai_link pcm051_dai_link = {
+	.name = "WM8974",
+	.stream_name = "WM8974",
+	.cpu_dai_name = "davinci-mcasp.0",
+	.codec_dai_name = "wm8974-hifi",
+	.codec_name = "wm8974-codec.1-001a",
+	.platform_name = "davinci-pcm-audio",
+	.init = pcm051_wm8974_init,
+	.ops = &pcm051_ops,
+};
+
+/* davinci pcm051 audio machine driver */
+static struct snd_soc_card pcm051_snd_soc_card = {
+	.name = "PCM051 audio",
+	.dai_link = &pcm051_dai_link,
+	.num_links = 1,
+};
+
+static struct platform_device *pcm051_snd_device;
+
+static int __init pcm051_init(void)
+{
+	struct snd_soc_card *pcm051_snd_dev_data;
+	int index;
+	int ret;
+
+	pcm051_snd_dev_data = &pcm051_snd_soc_card;
+	index = 0;
+
+	pcm051_snd_device = platform_device_alloc("soc-audio", index);
+	if (!pcm051_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(pcm051_snd_device, pcm051_snd_dev_data);
+	ret = platform_device_add(pcm051_snd_device);
+	if (ret)
+		platform_device_put(pcm051_snd_device);
+
+	return ret;
+}
+
+static void __exit pcm051_exit(void)
+{
+	platform_device_unregister(pcm051_snd_device);
+}
+
+module_init(pcm051_init);
+module_exit(pcm051_exit);
+
+MODULE_AUTHOR("Lars Poeschel");
+MODULE_DESCRIPTION("Phytec PCM051 development board ASoC driver");
+MODULE_LICENSE("GPL");
